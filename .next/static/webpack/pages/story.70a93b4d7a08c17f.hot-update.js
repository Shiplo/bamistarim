/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/story",{

/***/ "./node_modules/gsap/dist/Flip.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/dist/Flip.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\n\tvar _doc,\n\t    _win,\n\t    _docElement,\n\t    _body,\n\t    _divContainer,\n\t    _svgContainer,\n\t    _identityMatrix,\n\t    _gEl,\n\t    _transformProp = \"transform\",\n\t    _transformOriginProp = _transformProp + \"Origin\",\n\t    _hasOffsetBug,\n\t    _setDoc = function _setDoc(element) {\n\t  var doc = element.ownerDocument || element;\n\n\t  if (!(_transformProp in element.style) && \"msTransform\" in element.style) {\n\t    _transformProp = \"msTransform\";\n\t    _transformOriginProp = _transformProp + \"Origin\";\n\t  }\n\n\t  while (doc.parentNode && (doc = doc.parentNode)) {}\n\n\t  _win = window;\n\t  _identityMatrix = new Matrix2D();\n\n\t  if (doc) {\n\t    _doc = doc;\n\t    _docElement = doc.documentElement;\n\t    _body = doc.body;\n\t    _gEl = _doc.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n\t    _gEl.style.transform = \"none\";\n\t    var d1 = doc.createElement(\"div\"),\n\t        d2 = doc.createElement(\"div\");\n\n\t    _body.appendChild(d1);\n\n\t    d1.appendChild(d2);\n\t    d1.style.position = \"static\";\n\t    d1.style[_transformProp] = \"translate3d(0,0,1px)\";\n\t    _hasOffsetBug = d2.offsetParent !== d1;\n\n\t    _body.removeChild(d1);\n\t  }\n\n\t  return doc;\n\t},\n\t    _forceNonZeroScale = function _forceNonZeroScale(e) {\n\t  var a, cache;\n\n\t  while (e && e !== _body) {\n\t    cache = e._gsap;\n\t    cache && cache.uncache && cache.get(e, \"x\");\n\n\t    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n\t      cache.scaleX = cache.scaleY = 1e-4;\n\t      cache.renderTransform(1, cache);\n\t      a ? a.push(cache) : a = [cache];\n\t    }\n\n\t    e = e.parentNode;\n\t  }\n\n\t  return a;\n\t},\n\t    _svgTemps = [],\n\t    _divTemps = [],\n\t    _getDocScrollTop = function _getDocScrollTop() {\n\t  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;\n\t},\n\t    _getDocScrollLeft = function _getDocScrollLeft() {\n\t  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;\n\t},\n\t    _svgOwner = function _svgOwner(element) {\n\t  return element.ownerSVGElement || ((element.tagName + \"\").toLowerCase() === \"svg\" ? element : null);\n\t},\n\t    _isFixed = function _isFixed(element) {\n\t  if (_win.getComputedStyle(element).position === \"fixed\") {\n\t    return true;\n\t  }\n\n\t  element = element.parentNode;\n\n\t  if (element && element.nodeType === 1) {\n\t    return _isFixed(element);\n\t  }\n\t},\n\t    _createSibling = function _createSibling(element, i) {\n\t  if (element.parentNode && (_doc || _setDoc(element))) {\n\t    var svg = _svgOwner(element),\n\t        ns = svg ? svg.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\",\n\t        type = svg ? i ? \"rect\" : \"g\" : \"div\",\n\t        x = i !== 2 ? 0 : 100,\n\t        y = i === 3 ? 100 : 0,\n\t        css = \"position:absolute;display:block;pointer-events:none;margin:0;padding:0;\",\n\t        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, \"http\"), type) : _doc.createElement(type);\n\n\t    if (i) {\n\t      if (!svg) {\n\t        if (!_divContainer) {\n\t          _divContainer = _createSibling(element);\n\t          _divContainer.style.cssText = css;\n\t        }\n\n\t        e.style.cssText = css + \"width:0.1px;height:0.1px;top:\" + y + \"px;left:\" + x + \"px\";\n\n\t        _divContainer.appendChild(e);\n\t      } else {\n\t        _svgContainer || (_svgContainer = _createSibling(element));\n\t        e.setAttribute(\"width\", 0.01);\n\t        e.setAttribute(\"height\", 0.01);\n\t        e.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n\n\t        _svgContainer.appendChild(e);\n\t      }\n\t    }\n\n\t    return e;\n\t  }\n\n\t  throw \"Need document and parent.\";\n\t},\n\t    _consolidate = function _consolidate(m) {\n\t  var c = new Matrix2D(),\n\t      i = 0;\n\n\t  for (; i < m.numberOfItems; i++) {\n\t    c.multiply(m.getItem(i).matrix);\n\t  }\n\n\t  return c;\n\t},\n\t    _getCTM = function _getCTM(svg) {\n\t  var m = svg.getCTM(),\n\t      transform;\n\n\t  if (!m) {\n\t    transform = svg.style[_transformProp];\n\t    svg.style[_transformProp] = \"none\";\n\t    svg.appendChild(_gEl);\n\t    m = _gEl.getCTM();\n\t    svg.removeChild(_gEl);\n\t    transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n\t  }\n\n\t  return m || _identityMatrix.clone();\n\t},\n\t    _placeSiblings = function _placeSiblings(element, adjustGOffset) {\n\t  var svg = _svgOwner(element),\n\t      isRootSVG = element === svg,\n\t      siblings = svg ? _svgTemps : _divTemps,\n\t      parent = element.parentNode,\n\t      container,\n\t      m,\n\t      b,\n\t      x,\n\t      y,\n\t      cs;\n\n\t  if (element === _win) {\n\t    return element;\n\t  }\n\n\t  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n\t  container = svg ? _svgContainer : _divContainer;\n\n\t  if (svg) {\n\t    if (isRootSVG) {\n\t      b = _getCTM(element);\n\t      x = -b.e / b.a;\n\t      y = -b.f / b.d;\n\t      m = _identityMatrix;\n\t    } else if (element.getBBox) {\n\t      b = element.getBBox();\n\t      m = element.transform ? element.transform.baseVal : {};\n\t      m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix;\n\t      x = m.a * b.x + m.c * b.y;\n\t      y = m.b * b.x + m.d * b.y;\n\t    } else {\n\t      m = new Matrix2D();\n\t      x = y = 0;\n\t    }\n\n\t    if (adjustGOffset && element.tagName.toLowerCase() === \"g\") {\n\t      x = y = 0;\n\t    }\n\n\t    (isRootSVG ? svg : parent).appendChild(container);\n\t    container.setAttribute(\"transform\", \"matrix(\" + m.a + \",\" + m.b + \",\" + m.c + \",\" + m.d + \",\" + (m.e + x) + \",\" + (m.f + y) + \")\");\n\t  } else {\n\t    x = y = 0;\n\n\t    if (_hasOffsetBug) {\n\t      m = element.offsetParent;\n\t      b = element;\n\n\t      while (b && (b = b.parentNode) && b !== m && b.parentNode) {\n\t        if ((_win.getComputedStyle(b)[_transformProp] + \"\").length > 4) {\n\t          x = b.offsetLeft;\n\t          y = b.offsetTop;\n\t          b = 0;\n\t        }\n\t      }\n\t    }\n\n\t    cs = _win.getComputedStyle(element);\n\n\t    if (cs.position !== \"absolute\" && cs.position !== \"fixed\") {\n\t      m = element.offsetParent;\n\n\t      while (parent && parent !== m) {\n\t        x += parent.scrollLeft || 0;\n\t        y += parent.scrollTop || 0;\n\t        parent = parent.parentNode;\n\t      }\n\t    }\n\n\t    b = container.style;\n\t    b.top = element.offsetTop - y + \"px\";\n\t    b.left = element.offsetLeft - x + \"px\";\n\t    b[_transformProp] = cs[_transformProp];\n\t    b[_transformOriginProp] = cs[_transformOriginProp];\n\t    b.position = cs.position === \"fixed\" ? \"fixed\" : \"absolute\";\n\t    element.parentNode.appendChild(container);\n\t  }\n\n\t  return container;\n\t},\n\t    _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {\n\t  m.a = a;\n\t  m.b = b;\n\t  m.c = c;\n\t  m.d = d;\n\t  m.e = e;\n\t  m.f = f;\n\t  return m;\n\t};\n\n\tvar Matrix2D = function () {\n\t  function Matrix2D(a, b, c, d, e, f) {\n\t    if (a === void 0) {\n\t      a = 1;\n\t    }\n\n\t    if (b === void 0) {\n\t      b = 0;\n\t    }\n\n\t    if (c === void 0) {\n\t      c = 0;\n\t    }\n\n\t    if (d === void 0) {\n\t      d = 1;\n\t    }\n\n\t    if (e === void 0) {\n\t      e = 0;\n\t    }\n\n\t    if (f === void 0) {\n\t      f = 0;\n\t    }\n\n\t    _setMatrix(this, a, b, c, d, e, f);\n\t  }\n\n\t  var _proto = Matrix2D.prototype;\n\n\t  _proto.inverse = function inverse() {\n\t    var a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f,\n\t        determinant = a * d - b * c || 1e-10;\n\t    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n\t  };\n\n\t  _proto.multiply = function multiply(matrix) {\n\t    var a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f,\n\t        a2 = matrix.a,\n\t        b2 = matrix.c,\n\t        c2 = matrix.b,\n\t        d2 = matrix.d,\n\t        e2 = matrix.e,\n\t        f2 = matrix.f;\n\t    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);\n\t  };\n\n\t  _proto.clone = function clone() {\n\t    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n\t  };\n\n\t  _proto.equals = function equals(matrix) {\n\t    var a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f;\n\t    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n\t  };\n\n\t  _proto.apply = function apply(point, decoratee) {\n\t    if (decoratee === void 0) {\n\t      decoratee = {};\n\t    }\n\n\t    var x = point.x,\n\t        y = point.y,\n\t        a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f;\n\t    decoratee.x = x * a + y * c + e || 0;\n\t    decoratee.y = x * b + y * d + f || 0;\n\t    return decoratee;\n\t  };\n\n\t  return Matrix2D;\n\t}();\n\tfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n\t  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n\t    return new Matrix2D();\n\t  }\n\n\t  var zeroScales = _forceNonZeroScale(element),\n\t      svg = _svgOwner(element),\n\t      temps = svg ? _svgTemps : _divTemps,\n\t      container = _placeSiblings(element, adjustGOffset),\n\t      b1 = temps[0].getBoundingClientRect(),\n\t      b2 = temps[1].getBoundingClientRect(),\n\t      b3 = temps[2].getBoundingClientRect(),\n\t      parent = container.parentNode,\n\t      isFixed = !includeScrollInFixed && _isFixed(element),\n\t      m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));\n\n\t  parent.removeChild(container);\n\n\t  if (zeroScales) {\n\t    b1 = zeroScales.length;\n\n\t    while (b1--) {\n\t      b2 = zeroScales[b1];\n\t      b2.scaleX = b2.scaleY = 0;\n\t      b2.renderTransform(1, b2);\n\t    }\n\t  }\n\n\t  return inverse ? m.inverse() : m;\n\t}\n\n\t/*!\n\t * Flip 3.11.3\n\t * https://greensock.com\n\t *\n\t * @license Copyright 2008-2022, GreenSock. All rights reserved.\n\t * Subject to the terms at https://greensock.com/standard-license or for\n\t * Club GreenSock members, the agreement issued with that membership.\n\t * @author: Jack Doyle, jack@greensock.com\n\t*/\n\n\tvar _id = 1,\n\t    _toArray,\n\t    gsap,\n\t    _batch,\n\t    _batchAction,\n\t    _body$1,\n\t    _closestTenth,\n\t    _forEachBatch = function _forEachBatch(batch, name) {\n\t  return batch.actions.forEach(function (a) {\n\t    return a.vars[name] && a.vars[name](a);\n\t  });\n\t},\n\t    _batchLookup = {},\n\t    _RAD2DEG = 180 / Math.PI,\n\t    _DEG2RAD = Math.PI / 180,\n\t    _emptyObj = {},\n\t    _dashedNameLookup = {},\n\t    _memoizedRemoveProps = {},\n\t    _listToArray = function _listToArray(list) {\n\t  return typeof list === \"string\" ? list.split(\" \").join(\"\").split(\",\") : list;\n\t},\n\t    _callbacks = _listToArray(\"onStart,onUpdate,onComplete,onReverseComplete,onInterrupt\"),\n\t    _removeProps = _listToArray(\"transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight\"),\n\t    _getEl = function _getEl(target) {\n\t  return _toArray(target)[0] || console.warn(\"Element not found:\", target);\n\t},\n\t    _round = function _round(value) {\n\t  return Math.round(value * 10000) / 10000 || 0;\n\t},\n\t    _toggleClass = function _toggleClass(targets, className, action) {\n\t  return targets.forEach(function (el) {\n\t    return el.classList[action](className);\n\t  });\n\t},\n\t    _reserved = {\n\t  zIndex: 1,\n\t  kill: 1,\n\t  simple: 1,\n\t  spin: 1,\n\t  clearProps: 1,\n\t  targets: 1,\n\t  toggleClass: 1,\n\t  onComplete: 1,\n\t  onUpdate: 1,\n\t  onInterrupt: 1,\n\t  onStart: 1,\n\t  delay: 1,\n\t  repeat: 1,\n\t  repeatDelay: 1,\n\t  yoyo: 1,\n\t  scale: 1,\n\t  fade: 1,\n\t  absolute: 1,\n\t  props: 1,\n\t  onEnter: 1,\n\t  onLeave: 1,\n\t  custom: 1,\n\t  paused: 1,\n\t  nested: 1,\n\t  prune: 1,\n\t  absoluteOnLeave: 1\n\t},\n\t    _fitReserved = {\n\t  zIndex: 1,\n\t  simple: 1,\n\t  clearProps: 1,\n\t  scale: 1,\n\t  absolute: 1,\n\t  fitChild: 1,\n\t  getVars: 1,\n\t  props: 1\n\t},\n\t    _camelToDashed = function _camelToDashed(p) {\n\t  return p.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\t},\n\t    _copy = function _copy(obj, exclude) {\n\t  var result = {},\n\t      p;\n\n\t  for (p in obj) {\n\t    exclude[p] || (result[p] = obj[p]);\n\t  }\n\n\t  return result;\n\t},\n\t    _memoizedProps = {},\n\t    _memoizeProps = function _memoizeProps(props) {\n\t  var p = _memoizedProps[props] = _listToArray(props);\n\n\t  _memoizedRemoveProps[props] = p.concat(_removeProps);\n\t  return p;\n\t},\n\t    _getInverseGlobalMatrix = function _getInverseGlobalMatrix(el) {\n\t  var cache = el._gsap || gsap.core.getCache(el);\n\n\t  if (cache.gmCache === gsap.ticker.frame) {\n\t    return cache.gMatrix;\n\t  }\n\n\t  cache.gmCache = gsap.ticker.frame;\n\t  return cache.gMatrix = getGlobalMatrix(el, true, false, true);\n\t},\n\t    _getDOMDepth = function _getDOMDepth(el, invert, level) {\n\t  if (level === void 0) {\n\t    level = 0;\n\t  }\n\n\t  var parent = el.parentNode,\n\t      inc = 1000 * Math.pow(10, level) * (invert ? -1 : 1),\n\t      l = invert ? -inc * 900 : 0;\n\n\t  while (el) {\n\t    l += inc;\n\t    el = el.previousSibling;\n\t  }\n\n\t  return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n\t},\n\t    _orderByDOMDepth = function _orderByDOMDepth(comps, invert, isElStates) {\n\t  comps.forEach(function (comp) {\n\t    return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);\n\t  });\n\t  comps.sort(function (c1, c2) {\n\t    return c1.d - c2.d;\n\t  });\n\t  return comps;\n\t},\n\t    _recordInlineStyles = function _recordInlineStyles(elState, props) {\n\t  var style = elState.element.style,\n\t      a = elState.css = elState.css || [],\n\t      i = props.length,\n\t      p,\n\t      v;\n\n\t  while (i--) {\n\t    p = props[i];\n\t    v = style[p] || style.getPropertyValue(p);\n\t    a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n\t  }\n\n\t  return style;\n\t},\n\t    _applyInlineStyles = function _applyInlineStyles(state) {\n\t  var css = state.css,\n\t      style = state.element.style,\n\t      i = 0;\n\t  state.cache.uncache = 1;\n\n\t  for (; i < css.length; i += 2) {\n\t    css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);\n\t  }\n\t},\n\t    _setFinalStates = function _setFinalStates(comps, onlyTransforms) {\n\t  comps.forEach(function (c) {\n\t    return c.a.cache.uncache = 1;\n\t  });\n\t  onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n\t},\n\t    _absoluteProps = \"paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition\".split(\",\"),\n\t    _makeAbsolute = function _makeAbsolute(elState, fallbackNode, ignoreBatch) {\n\t  var element = elState.element,\n\t      width = elState.width,\n\t      height = elState.height,\n\t      uncache = elState.uncache,\n\t      getProp = elState.getProp,\n\t      style = element.style,\n\t      i = 4,\n\t      result,\n\t      displayIsNone,\n\t      cs;\n\t  typeof fallbackNode !== \"object\" && (fallbackNode = elState);\n\n\t  if (_batch && ignoreBatch !== 1) {\n\t    _batch._abs.push({\n\t      t: element,\n\t      b: elState,\n\t      a: elState,\n\t      sd: 0\n\t    });\n\n\t    _batch._final.push(function () {\n\t      return (elState.cache.uncache = 1) && _applyInlineStyles(elState);\n\t    });\n\n\t    return element;\n\t  }\n\n\t  displayIsNone = getProp(\"display\") === \"none\";\n\n\t  if (!elState.isVisible || displayIsNone) {\n\t    displayIsNone && (_recordInlineStyles(elState, [\"display\"]).display = fallbackNode.display);\n\t    elState.matrix = fallbackNode.matrix;\n\t    elState.width = width = elState.width || fallbackNode.width;\n\t    elState.height = height = elState.height || fallbackNode.height;\n\t  }\n\n\t  _recordInlineStyles(elState, _absoluteProps);\n\n\t  cs = window.getComputedStyle(element);\n\n\t  while (i--) {\n\t    style[_absoluteProps[i]] = cs[_absoluteProps[i]];\n\t  }\n\n\t  style.gridArea = \"1 / 1 / 1 / 1\";\n\t  style.transition = \"none\";\n\t  style.position = \"absolute\";\n\t  style.width = width + \"px\";\n\t  style.height = height + \"px\";\n\t  style.top || (style.top = \"0px\");\n\t  style.left || (style.left = \"0px\");\n\n\t  if (uncache) {\n\t    result = new ElementState(element);\n\t  } else {\n\t    result = _copy(elState, _emptyObj);\n\t    result.position = \"absolute\";\n\n\t    if (elState.simple) {\n\t      var bounds = element.getBoundingClientRect();\n\t      result.matrix = new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop());\n\t    } else {\n\t      result.matrix = getGlobalMatrix(element, false, false, true);\n\t    }\n\t  }\n\n\t  result = _fit(result, elState, true);\n\t  elState.x = _closestTenth(result.x, 0.01);\n\t  elState.y = _closestTenth(result.y, 0.01);\n\t  return element;\n\t},\n\t    _filterComps = function _filterComps(comps, targets) {\n\t  if (targets !== true) {\n\t    targets = _toArray(targets);\n\t    comps = comps.filter(function (c) {\n\t      if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {\n\t        return true;\n\t      } else {\n\t        c.t._gsap.renderTransform(1);\n\n\t        if (c.b.isVisible) {\n\t          c.t.style.width = c.b.width + \"px\";\n\t          c.t.style.height = c.b.height + \"px\";\n\t        }\n\t      }\n\t    });\n\t  }\n\n\t  return comps;\n\t},\n\t    _makeCompsAbsolute = function _makeCompsAbsolute(comps) {\n\t  return _orderByDOMDepth(comps, true).forEach(function (c) {\n\t    return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);\n\t  });\n\t},\n\t    _findElStateInState = function _findElStateInState(state, other) {\n\t  return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];\n\t},\n\t    _parseElementState = function _parseElementState(elOrNode, props, simple, other) {\n\t  return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === \"string\" ? _getEl(elOrNode) || console.warn(elOrNode + \" not found\") : elOrNode, props, simple);\n\t},\n\t    _recordProps = function _recordProps(elState, props) {\n\t  var getProp = gsap.getProperty(elState.element, null, \"native\"),\n\t      obj = elState.props = {},\n\t      i = props.length;\n\n\t  while (i--) {\n\t    obj[props[i]] = (getProp(props[i]) + \"\").trim();\n\t  }\n\n\t  obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n\t  return elState;\n\t},\n\t    _applyProps = function _applyProps(element, props) {\n\t  var style = element.style || element,\n\t      p;\n\n\t  for (p in props) {\n\t    style[p] = props[p];\n\t  }\n\t},\n\t    _getID = function _getID(el) {\n\t  var id = el.getAttribute(\"data-flip-id\");\n\t  id || el.setAttribute(\"data-flip-id\", id = \"auto-\" + _id++);\n\t  return id;\n\t},\n\t    _elementsFromElementStates = function _elementsFromElementStates(elStates) {\n\t  return elStates.map(function (elState) {\n\t    return elState.element;\n\t  });\n\t},\n\t    _handleCallback = function _handleCallback(callback, elStates, tl) {\n\t  return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);\n\t},\n\t    _fit = function _fit(fromState, toState, scale, applyProps, fitChild, vars) {\n\t  var element = fromState.element,\n\t      cache = fromState.cache,\n\t      parent = fromState.parent,\n\t      x = fromState.x,\n\t      y = fromState.y,\n\t      width = toState.width,\n\t      height = toState.height,\n\t      scaleX = toState.scaleX,\n\t      scaleY = toState.scaleY,\n\t      rotation = toState.rotation,\n\t      bounds = toState.bounds,\n\t      cssText = vars && element.style.cssText,\n\t      transform = vars && element.getBBox && element.getAttribute(\"transform\"),\n\t      dimensionState = fromState,\n\t      _toState$matrix = toState.matrix,\n\t      e = _toState$matrix.e,\n\t      f = _toState$matrix.f,\n\t      deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation,\n\t      simple = !deep && fromState.simple && toState.simple && !fitChild,\n\t      skewX,\n\t      fromPoint,\n\t      toPoint,\n\t      getProp,\n\t      parentMatrix,\n\t      matrix,\n\t      bbox;\n\n\t  if (simple || !parent) {\n\t    scaleX = scaleY = 1;\n\t    rotation = skewX = 0;\n\t  } else {\n\t    parentMatrix = _getInverseGlobalMatrix(parent);\n\t    matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix);\n\t    rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n\t    skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360;\n\t    scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));\n\t    scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD);\n\n\t    if (fitChild) {\n\t      fitChild = _toArray(fitChild)[0];\n\t      getProp = gsap.getProperty(fitChild);\n\t      bbox = fitChild.getBBox && typeof fitChild.getBBox === \"function\" && fitChild.getBBox();\n\t      dimensionState = {\n\t        scaleX: getProp(\"scaleX\"),\n\t        scaleY: getProp(\"scaleY\"),\n\t        width: bbox ? bbox.width : Math.ceil(parseFloat(getProp(\"width\", \"px\"))),\n\t        height: bbox ? bbox.height : parseFloat(getProp(\"height\", \"px\"))\n\t      };\n\t    }\n\n\t    cache.rotation = rotation + \"deg\";\n\t    cache.skewX = skewX + \"deg\";\n\t  }\n\n\t  if (scale) {\n\t    scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width;\n\t    scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;\n\t    cache.scaleX = scaleX;\n\t    cache.scaleY = scaleY;\n\t  } else {\n\t    width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);\n\t    height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);\n\t    element.style.width = width + \"px\";\n\t    element.style.height = height + \"px\";\n\t  }\n\n\t  applyProps && _applyProps(element, toState.props);\n\n\t  if (simple || !parent) {\n\t    x += e - fromState.matrix.e;\n\t    y += f - fromState.matrix.f;\n\t  } else if (deep || parent !== toState.parent) {\n\t    cache.renderTransform(1, cache);\n\t    matrix = getGlobalMatrix(fitChild || element, false, false, true);\n\t    fromPoint = parentMatrix.apply({\n\t      x: matrix.e,\n\t      y: matrix.f\n\t    });\n\t    toPoint = parentMatrix.apply({\n\t      x: e,\n\t      y: f\n\t    });\n\t    x += toPoint.x - fromPoint.x;\n\t    y += toPoint.y - fromPoint.y;\n\t  } else {\n\t    parentMatrix.e = parentMatrix.f = 0;\n\t    toPoint = parentMatrix.apply({\n\t      x: e - fromState.matrix.e,\n\t      y: f - fromState.matrix.f\n\t    });\n\t    x += toPoint.x;\n\t    y += toPoint.y;\n\t  }\n\n\t  x = _closestTenth(x, 0.02);\n\t  y = _closestTenth(y, 0.02);\n\n\t  if (vars && !(vars instanceof ElementState)) {\n\t    element.style.cssText = cssText;\n\t    element.getBBox && element.setAttribute(\"transform\", transform || \"\");\n\t    cache.uncache = 1;\n\t  } else {\n\t    cache.x = x + \"px\";\n\t    cache.y = y + \"px\";\n\t    cache.renderTransform(1, cache);\n\t  }\n\n\t  if (vars) {\n\t    vars.x = x;\n\t    vars.y = y;\n\t    vars.rotation = rotation;\n\t    vars.skewX = skewX;\n\n\t    if (scale) {\n\t      vars.scaleX = scaleX;\n\t      vars.scaleY = scaleY;\n\t    } else {\n\t      vars.width = width;\n\t      vars.height = height;\n\t    }\n\t  }\n\n\t  return vars || cache;\n\t},\n\t    _parseState = function _parseState(targetsOrState, vars) {\n\t  return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);\n\t},\n\t    _getChangingElState = function _getChangingElState(toState, fromState, id) {\n\t  var to1 = toState.idLookup[id],\n\t      to2 = toState.alt[id];\n\t  return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n\t},\n\t    _bodyMetrics = [],\n\t    _bodyProps = \"width,height,overflowX,overflowY\".split(\",\"),\n\t    _bodyLocked,\n\t    _lockBodyScroll = function _lockBodyScroll(lock) {\n\t  if (lock !== _bodyLocked) {\n\t    var s = _body$1.style,\n\t        w = _body$1.clientWidth === window.outerWidth,\n\t        h = _body$1.clientHeight === window.outerHeight,\n\t        i = 4;\n\n\t    if (lock && (w || h)) {\n\t      while (i--) {\n\t        _bodyMetrics[i] = s[_bodyProps[i]];\n\t      }\n\n\t      if (w) {\n\t        s.width = _body$1.clientWidth + \"px\";\n\t        s.overflowY = \"hidden\";\n\t      }\n\n\t      if (h) {\n\t        s.height = _body$1.clientHeight + \"px\";\n\t        s.overflowX = \"hidden\";\n\t      }\n\n\t      _bodyLocked = lock;\n\t    } else if (_bodyLocked) {\n\t      while (i--) {\n\t        _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));\n\t      }\n\n\t      _bodyLocked = lock;\n\t    }\n\t  }\n\t},\n\t    _fromTo = function _fromTo(fromState, toState, vars, relative) {\n\t  fromState instanceof FlipState && toState instanceof FlipState || console.warn(\"Not a valid state object.\");\n\t  vars = vars || {};\n\n\t  var _vars = vars,\n\t      clearProps = _vars.clearProps,\n\t      onEnter = _vars.onEnter,\n\t      onLeave = _vars.onLeave,\n\t      absolute = _vars.absolute,\n\t      absoluteOnLeave = _vars.absoluteOnLeave,\n\t      custom = _vars.custom,\n\t      delay = _vars.delay,\n\t      paused = _vars.paused,\n\t      repeat = _vars.repeat,\n\t      repeatDelay = _vars.repeatDelay,\n\t      yoyo = _vars.yoyo,\n\t      toggleClass = _vars.toggleClass,\n\t      nested = _vars.nested,\n\t      _zIndex = _vars.zIndex,\n\t      scale = _vars.scale,\n\t      fade = _vars.fade,\n\t      stagger = _vars.stagger,\n\t      spin = _vars.spin,\n\t      prune = _vars.prune,\n\t      props = (\"props\" in vars ? vars : fromState).props,\n\t      tweenVars = _copy(vars, _reserved),\n\t      animation = gsap.timeline({\n\t    delay: delay,\n\t    paused: paused,\n\t    repeat: repeat,\n\t    repeatDelay: repeatDelay,\n\t    yoyo: yoyo,\n\t    data: \"isFlip\"\n\t  }),\n\t      remainingProps = tweenVars,\n\t      entering = [],\n\t      leaving = [],\n\t      comps = [],\n\t      swapOutTargets = [],\n\t      spinNum = spin === true ? 1 : spin || 0,\n\t      spinFunc = typeof spin === \"function\" ? spin : function () {\n\t    return spinNum;\n\t  },\n\t      interrupted = fromState.interrupted || toState.interrupted,\n\t      addFunc = animation[relative !== 1 ? \"to\" : \"from\"],\n\t      v,\n\t      p,\n\t      endTime,\n\t      i,\n\t      el,\n\t      comp,\n\t      state,\n\t      targets,\n\t      finalStates,\n\t      fromNode,\n\t      toNode,\n\t      run,\n\t      a,\n\t      b;\n\n\t  for (p in toState.idLookup) {\n\t    toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n\t    el = toNode.element;\n\t    fromNode = fromState.idLookup[p];\n\t    fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);\n\n\t    if (fromNode) {\n\t      comp = {\n\t        t: el,\n\t        b: fromNode,\n\t        a: toNode,\n\t        sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1\n\t      };\n\t      comps.push(comp);\n\n\t      if (comp.sd) {\n\t        if (comp.sd < 0) {\n\t          comp.b = toNode;\n\t          comp.a = fromNode;\n\t        }\n\n\t        interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);\n\t        fade && comps.push(comp.swap = {\n\t          t: fromNode.element,\n\t          b: comp.b,\n\t          a: comp.a,\n\t          sd: -comp.sd,\n\t          swap: comp\n\t        });\n\t      }\n\n\t      el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;\n\t    } else if (toNode.isVisible) {\n\t      comps.push({\n\t        t: el,\n\t        b: _copy(toNode, {\n\t          isVisible: 1\n\t        }),\n\t        a: toNode,\n\t        sd: 0,\n\t        entering: 1\n\t      });\n\t      el._flip = _batch ? _batch.timeline : animation;\n\t    }\n\t  }\n\n\t  props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function (p) {\n\t    return tweenVars[p] = function (i) {\n\t      return comps[i].a.props[p];\n\t    };\n\t  });\n\t  comps.finalStates = finalStates = [];\n\n\t  run = function run() {\n\t    _orderByDOMDepth(comps);\n\n\t    _lockBodyScroll(true);\n\n\t    for (i = 0; i < comps.length; i++) {\n\t      comp = comps[i];\n\t      a = comp.a;\n\t      b = comp.b;\n\n\t      if (prune && !a.isDifferent(b) && !comp.entering) {\n\t        comps.splice(i--, 1);\n\t      } else {\n\t        el = comp.t;\n\t        nested && !(comp.sd < 0) && i && (a.matrix = getGlobalMatrix(el, false, false, true));\n\n\t        if (b.isVisible && a.isVisible) {\n\t          if (comp.sd < 0) {\n\t            state = new ElementState(el, props, fromState.simple);\n\n\t            _fit(state, a, scale, 0, 0, state);\n\n\t            state.matrix = getGlobalMatrix(el, false, false, true);\n\t            state.css = comp.b.css;\n\t            comp.a = a = state;\n\t            fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);\n\t            stagger && swapOutTargets.push(el);\n\t          } else if (comp.sd > 0 && fade) {\n\t            el.style.opacity = interrupted ? a.opacity - b.opacity : \"0\";\n\t          }\n\n\t          _fit(a, b, scale, props);\n\t        } else if (b.isVisible !== a.isVisible) {\n\t          if (!b.isVisible) {\n\t            a.isVisible && entering.push(a);\n\t            comps.splice(i--, 1);\n\t          } else if (!a.isVisible) {\n\t            b.css = a.css;\n\t            leaving.push(b);\n\t            comps.splice(i--, 1);\n\t            absolute && nested && _fit(a, b, scale, props);\n\t          }\n\t        }\n\n\t        if (!scale) {\n\t          el.style.maxWidth = Math.max(a.width, b.width) + \"px\";\n\t          el.style.maxHeight = Math.max(a.height, b.height) + \"px\";\n\t          el.style.minWidth = Math.min(a.width, b.width) + \"px\";\n\t          el.style.minHeight = Math.min(a.height, b.height) + \"px\";\n\t        }\n\n\t        nested && toggleClass && el.classList.add(toggleClass);\n\t      }\n\n\t      finalStates.push(a);\n\t    }\n\n\t    var classTargets;\n\n\t    if (toggleClass) {\n\t      classTargets = finalStates.map(function (s) {\n\t        return s.element;\n\t      });\n\t      nested && classTargets.forEach(function (e) {\n\t        return e.classList.remove(toggleClass);\n\t      });\n\t    }\n\n\t    _lockBodyScroll(false);\n\n\t    if (scale) {\n\t      tweenVars.scaleX = function (i) {\n\t        return comps[i].a.scaleX;\n\t      };\n\n\t      tweenVars.scaleY = function (i) {\n\t        return comps[i].a.scaleY;\n\t      };\n\t    } else {\n\t      tweenVars.width = function (i) {\n\t        return comps[i].a.width + \"px\";\n\t      };\n\n\t      tweenVars.height = function (i) {\n\t        return comps[i].a.height + \"px\";\n\t      };\n\n\t      tweenVars.autoRound = vars.autoRound || false;\n\t    }\n\n\t    tweenVars.x = function (i) {\n\t      return comps[i].a.x + \"px\";\n\t    };\n\n\t    tweenVars.y = function (i) {\n\t      return comps[i].a.y + \"px\";\n\t    };\n\n\t    tweenVars.rotation = function (i) {\n\t      return comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n\t    };\n\n\t    tweenVars.skewX = function (i) {\n\t      return comps[i].a.skewX;\n\t    };\n\n\t    targets = comps.map(function (c) {\n\t      return c.t;\n\t    });\n\n\t    if (_zIndex || _zIndex === 0) {\n\t      tweenVars.modifiers = {\n\t        zIndex: function zIndex() {\n\t          return _zIndex;\n\t        }\n\t      };\n\t      tweenVars.zIndex = _zIndex;\n\t      tweenVars.immediateRender = vars.immediateRender !== false;\n\t    }\n\n\t    fade && (tweenVars.opacity = function (i) {\n\t      return comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : \"+=0\";\n\t    });\n\n\t    if (swapOutTargets.length) {\n\t      stagger = gsap.utils.distribute(stagger);\n\t      var dummyArray = targets.slice(swapOutTargets.length);\n\n\t      tweenVars.stagger = function (i, el) {\n\t        return stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n\t      };\n\t    }\n\n\t    _callbacks.forEach(function (name) {\n\t      return vars[name] && animation.eventCallback(name, vars[name], vars[name + \"Params\"]);\n\t    });\n\n\t    if (custom && targets.length) {\n\t      remainingProps = _copy(tweenVars, _reserved);\n\n\t      if (\"scale\" in custom) {\n\t        custom.scaleX = custom.scaleY = custom.scale;\n\t        delete custom.scale;\n\t      }\n\n\t      for (p in custom) {\n\t        v = _copy(custom[p], _fitReserved);\n\t        v[p] = tweenVars[p];\n\t        !(\"duration\" in v) && \"duration\" in tweenVars && (v.duration = tweenVars.duration);\n\t        v.stagger = tweenVars.stagger;\n\t        addFunc.call(animation, targets, v, 0);\n\t        delete remainingProps[p];\n\t      }\n\t    }\n\n\t    if (targets.length || leaving.length || entering.length) {\n\t      toggleClass && animation.add(function () {\n\t        return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? \"remove\" : \"add\");\n\t      }, 0) && !paused && _toggleClass(classTargets, toggleClass, \"add\");\n\t      targets.length && addFunc.call(animation, targets, remainingProps, 0);\n\t    }\n\n\t    _handleCallback(onEnter, entering, animation);\n\n\t    _handleCallback(onLeave, leaving, animation);\n\n\t    var batchTl = _batch && _batch.timeline;\n\n\t    if (batchTl) {\n\t      batchTl.add(animation, 0);\n\n\t      _batch._final.push(function () {\n\t        return _setFinalStates(comps, !clearProps);\n\t      });\n\t    }\n\n\t    endTime = animation.duration();\n\t    animation.call(function () {\n\t      var forward = animation.time() >= endTime;\n\t      forward && !batchTl && _setFinalStates(comps, !clearProps);\n\t      toggleClass && _toggleClass(classTargets, toggleClass, forward ? \"remove\" : \"add\");\n\t    });\n\t  };\n\n\t  absoluteOnLeave && (absolute = comps.filter(function (comp) {\n\t    return !comp.sd && !comp.a.isVisible && comp.b.isVisible;\n\t  }).map(function (comp) {\n\t    return comp.a.element;\n\t  }));\n\n\t  if (_batch) {\n\t    var _batch$_abs;\n\n\t    absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));\n\n\t    _batch._run.push(run);\n\t  } else {\n\t    absolute && _makeCompsAbsolute(_filterComps(comps, absolute));\n\t    run();\n\t  }\n\n\t  var anim = _batch ? _batch.timeline : animation;\n\n\t  anim.revert = function () {\n\t    return _killFlip(anim, 1);\n\t  };\n\n\t  return anim;\n\t},\n\t    _interrupt = function _interrupt(tl) {\n\t  tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n\t  tl.getChildren(true, false, true).forEach(_interrupt);\n\t},\n\t    _killFlip = function _killFlip(tl, action) {\n\t  if (tl && tl.progress() < 1 && !tl.paused()) {\n\t    if (action) {\n\t      _interrupt(tl);\n\n\t      action < 2 && tl.progress(1);\n\t      tl.kill();\n\t    }\n\n\t    return true;\n\t  }\n\t},\n\t    _createLookup = function _createLookup(state) {\n\t  var lookup = state.idLookup = {},\n\t      alt = state.alt = {},\n\t      elStates = state.elementStates,\n\t      i = elStates.length,\n\t      elState;\n\n\t  while (i--) {\n\t    elState = elStates[i];\n\t    lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;\n\t  }\n\t};\n\n\tvar FlipState = function () {\n\t  function FlipState(targets, vars, targetsAreElementStates) {\n\t    this.props = vars && vars.props;\n\t    this.simple = !!(vars && vars.simple);\n\n\t    if (targetsAreElementStates) {\n\t      this.targets = _elementsFromElementStates(targets);\n\t      this.elementStates = targets;\n\n\t      _createLookup(this);\n\t    } else {\n\t      this.targets = _toArray(targets);\n\t      var soft = vars && (vars.kill === false || vars.batch && !vars.kill);\n\t      _batch && !soft && _batch._kill.push(this);\n\t      this.update(soft || !!_batch);\n\t    }\n\t  }\n\n\t  var _proto = FlipState.prototype;\n\n\t  _proto.update = function update(soft) {\n\t    var _this = this;\n\n\t    this.elementStates = this.targets.map(function (el) {\n\t      return new ElementState(el, _this.props, _this.simple);\n\t    });\n\n\t    _createLookup(this);\n\n\t    this.interrupt(soft);\n\t    this.recordInlineStyles();\n\t    return this;\n\t  };\n\n\t  _proto.clear = function clear() {\n\t    this.targets.length = this.elementStates.length = 0;\n\n\t    _createLookup(this);\n\n\t    return this;\n\t  };\n\n\t  _proto.fit = function fit(state, scale, nested) {\n\t    var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true),\n\t        toElStates = (state || this).idLookup,\n\t        i = 0,\n\t        fromNode,\n\t        toNode;\n\n\t    for (; i < elStatesInOrder.length; i++) {\n\t      fromNode = elStatesInOrder[i];\n\t      nested && (fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true));\n\t      toNode = toElStates[fromNode.id];\n\t      toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n\t      fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true);\n\t    }\n\n\t    return this;\n\t  };\n\n\t  _proto.getProperty = function getProperty(element, property) {\n\t    var es = this.getElementState(element) || _emptyObj;\n\n\t    return (property in es ? es : es.props || _emptyObj)[property];\n\t  };\n\n\t  _proto.add = function add(state) {\n\t    var i = state.targets.length,\n\t        lookup = this.idLookup,\n\t        alt = this.alt,\n\t        index,\n\t        es,\n\t        es2;\n\n\t    while (i--) {\n\t      es = state.elementStates[i];\n\t      es2 = lookup[es.id];\n\n\t      if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {\n\t        index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);\n\t        this.targets.splice(index, 1, state.targets[i]);\n\t        this.elementStates.splice(index, 1, es);\n\t      } else {\n\t        this.targets.push(state.targets[i]);\n\t        this.elementStates.push(es);\n\t      }\n\t    }\n\n\t    state.interrupted && (this.interrupted = true);\n\t    state.simple || (this.simple = false);\n\n\t    _createLookup(this);\n\n\t    return this;\n\t  };\n\n\t  _proto.compare = function compare(state) {\n\t    var l1 = state.idLookup,\n\t        l2 = this.idLookup,\n\t        unchanged = [],\n\t        changed = [],\n\t        enter = [],\n\t        leave = [],\n\t        targets = [],\n\t        a1 = state.alt,\n\t        a2 = this.alt,\n\t        place = function place(s1, s2, el) {\n\t      return (s1.isVisible !== s2.isVisible ? s1.isVisible ? enter : leave : s1.isVisible ? changed : unchanged).push(el) && targets.push(el);\n\t    },\n\t        placeIfDoesNotExist = function placeIfDoesNotExist(s1, s2, el) {\n\t      return targets.indexOf(el) < 0 && place(s1, s2, el);\n\t    },\n\t        s1,\n\t        s2,\n\t        p,\n\t        el,\n\t        s1Alt,\n\t        s2Alt,\n\t        c1,\n\t        c2;\n\n\t    for (p in l1) {\n\t      s1Alt = a1[p];\n\t      s2Alt = a2[p];\n\t      s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);\n\t      el = s1.element;\n\t      s2 = l2[p];\n\n\t      if (s2Alt) {\n\t        c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;\n\t        c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1;\n\n\t        if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {\n\t          (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);\n\t          targets.push(c1.element, c2.element);\n\t        } else {\n\t          place(c1, c2, c1.element);\n\t        }\n\n\t        s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);\n\t        placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);\n\t        placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);\n\t        s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);\n\t      } else {\n\t        !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);\n\t        s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);\n\t      }\n\t    }\n\n\t    for (p in l2) {\n\t      if (!l1[p]) {\n\t        leave.push(l2[p].element);\n\t        a2[p] && leave.push(a2[p].element);\n\t      }\n\t    }\n\n\t    return {\n\t      changed: changed,\n\t      unchanged: unchanged,\n\t      enter: enter,\n\t      leave: leave\n\t    };\n\t  };\n\n\t  _proto.recordInlineStyles = function recordInlineStyles() {\n\t    var props = _memoizedRemoveProps[this.props] || _removeProps,\n\t        i = this.elementStates.length;\n\n\t    while (i--) {\n\t      _recordInlineStyles(this.elementStates[i], props);\n\t    }\n\t  };\n\n\t  _proto.interrupt = function interrupt(soft) {\n\t    var _this2 = this;\n\n\t    var timelines = [];\n\t    this.targets.forEach(function (t) {\n\t      var tl = t._flip,\n\t          foundInProgress = _killFlip(tl, soft ? 0 : 1);\n\n\t      soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function () {\n\t        return _this2.updateVisibility();\n\t      });\n\t      foundInProgress && timelines.push(tl);\n\t    });\n\t    !soft && timelines.length && this.updateVisibility();\n\t    this.interrupted || (this.interrupted = !!timelines.length);\n\t  };\n\n\t  _proto.updateVisibility = function updateVisibility() {\n\t    this.elementStates.forEach(function (es) {\n\t      var b = es.element.getBoundingClientRect();\n\t      es.isVisible = !!(b.width || b.height || b.top || b.left);\n\t      es.uncache = 1;\n\t    });\n\t  };\n\n\t  _proto.getElementState = function getElementState(element) {\n\t    return this.elementStates[this.targets.indexOf(_getEl(element))];\n\t  };\n\n\t  _proto.makeAbsolute = function makeAbsolute() {\n\t    return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n\t  };\n\n\t  return FlipState;\n\t}();\n\n\tvar ElementState = function () {\n\t  function ElementState(element, props, simple) {\n\t    this.element = element;\n\t    this.update(props, simple);\n\t  }\n\n\t  var _proto2 = ElementState.prototype;\n\n\t  _proto2.isDifferent = function isDifferent(state) {\n\t    var b1 = this.bounds,\n\t        b2 = state.bounds;\n\t    return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);\n\t  };\n\n\t  _proto2.update = function update(props, simple) {\n\t    var self = this,\n\t        element = self.element,\n\t        getProp = gsap.getProperty(element),\n\t        cache = gsap.core.getCache(element),\n\t        bounds = element.getBoundingClientRect(),\n\t        bbox = element.getBBox && typeof element.getBBox === \"function\" && element.nodeName.toLowerCase() !== \"svg\" && element.getBBox(),\n\t        m = simple ? new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop()) : getGlobalMatrix(element, false, false, true);\n\t    self.getProp = getProp;\n\t    self.element = element;\n\t    self.id = _getID(element);\n\t    self.matrix = m;\n\t    self.cache = cache;\n\t    self.bounds = bounds;\n\t    self.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n\t    self.display = getProp(\"display\");\n\t    self.position = getProp(\"position\");\n\t    self.parent = element.parentNode;\n\t    self.x = getProp(\"x\");\n\t    self.y = getProp(\"y\");\n\t    self.scaleX = cache.scaleX;\n\t    self.scaleY = cache.scaleY;\n\t    self.rotation = getProp(\"rotation\");\n\t    self.skewX = getProp(\"skewX\");\n\t    self.opacity = getProp(\"opacity\");\n\t    self.width = bbox ? bbox.width : _closestTenth(getProp(\"width\", \"px\"), 0.04);\n\t    self.height = bbox ? bbox.height : _closestTenth(getProp(\"height\", \"px\"), 0.04);\n\t    props && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));\n\t    self.ctm = element.getCTM && element.nodeName.toLowerCase() === \"svg\" && _getCTM(element).inverse();\n\t    self.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1;\n\t    self.uncache = 0;\n\t  };\n\n\t  return ElementState;\n\t}();\n\n\tvar FlipAction = function () {\n\t  function FlipAction(vars, batch) {\n\t    this.vars = vars;\n\t    this.batch = batch;\n\t    this.states = [];\n\t    this.timeline = batch.timeline;\n\t  }\n\n\t  var _proto3 = FlipAction.prototype;\n\n\t  _proto3.getStateById = function getStateById(id) {\n\t    var i = this.states.length;\n\n\t    while (i--) {\n\t      if (this.states[i].idLookup[id]) {\n\t        return this.states[i];\n\t      }\n\t    }\n\t  };\n\n\t  _proto3.kill = function kill() {\n\t    this.batch.remove(this);\n\t  };\n\n\t  return FlipAction;\n\t}();\n\n\tvar FlipBatch = function () {\n\t  function FlipBatch(id) {\n\t    this.id = id;\n\t    this.actions = [];\n\t    this._kill = [];\n\t    this._final = [];\n\t    this._abs = [];\n\t    this._run = [];\n\t    this.data = {};\n\t    this.state = new FlipState();\n\t    this.timeline = gsap.timeline();\n\t  }\n\n\t  var _proto4 = FlipBatch.prototype;\n\n\t  _proto4.add = function add(config) {\n\t    var result = this.actions.filter(function (action) {\n\t      return action.vars === config;\n\t    });\n\n\t    if (result.length) {\n\t      return result[0];\n\t    }\n\n\t    result = new FlipAction(typeof config === \"function\" ? {\n\t      animate: config\n\t    } : config, this);\n\t    this.actions.push(result);\n\t    return result;\n\t  };\n\n\t  _proto4.remove = function remove(action) {\n\t    var i = this.actions.indexOf(action);\n\t    i >= 0 && this.actions.splice(i, 1);\n\t    return this;\n\t  };\n\n\t  _proto4.getState = function getState(merge) {\n\t    var _this3 = this;\n\n\t    var prevBatch = _batch,\n\t        prevAction = _batchAction;\n\t    _batch = this;\n\t    this.state.clear();\n\t    this._kill.length = 0;\n\t    this.actions.forEach(function (action) {\n\t      if (action.vars.getState) {\n\t        action.states.length = 0;\n\t        _batchAction = action;\n\t        action.state = action.vars.getState(action);\n\t      }\n\n\t      merge && action.states.forEach(function (s) {\n\t        return _this3.state.add(s);\n\t      });\n\t    });\n\t    _batchAction = prevAction;\n\t    _batch = prevBatch;\n\t    this.killConflicts();\n\t    return this;\n\t  };\n\n\t  _proto4.animate = function animate() {\n\t    var _this4 = this;\n\n\t    var prevBatch = _batch,\n\t        tl = this.timeline,\n\t        i = this.actions.length,\n\t        finalStates,\n\t        endTime;\n\t    _batch = this;\n\t    tl.clear();\n\t    this._abs.length = this._final.length = this._run.length = 0;\n\t    this.actions.forEach(function (a) {\n\t      a.vars.animate && a.vars.animate(a);\n\t      var onEnter = a.vars.onEnter,\n\t          onLeave = a.vars.onLeave,\n\t          targets = a.targets,\n\t          s,\n\t          result;\n\n\t      if (targets && targets.length && (onEnter || onLeave)) {\n\t        s = new FlipState();\n\t        a.states.forEach(function (state) {\n\t          return s.add(state);\n\t        });\n\t        result = s.compare(Flip.getState(targets));\n\t        result.enter.length && onEnter && onEnter(result.enter);\n\t        result.leave.length && onLeave && onLeave(result.leave);\n\t      }\n\t    });\n\n\t    _makeCompsAbsolute(this._abs);\n\n\t    this._run.forEach(function (f) {\n\t      return f();\n\t    });\n\n\t    endTime = tl.duration();\n\t    finalStates = this._final.slice(0);\n\t    tl.add(function () {\n\t      if (endTime <= tl.time()) {\n\t        finalStates.forEach(function (f) {\n\t          return f();\n\t        });\n\n\t        _forEachBatch(_this4, \"onComplete\");\n\t      }\n\t    });\n\t    _batch = prevBatch;\n\n\t    while (i--) {\n\t      this.actions[i].vars.once && this.actions[i].kill();\n\t    }\n\n\t    _forEachBatch(this, \"onStart\");\n\n\t    tl.restart();\n\t    return this;\n\t  };\n\n\t  _proto4.loadState = function loadState(done) {\n\t    done || (done = function done() {\n\t      return 0;\n\t    });\n\t    var queue = [];\n\t    this.actions.forEach(function (c) {\n\t      if (c.vars.loadState) {\n\t        var i,\n\t            f = function f(targets) {\n\t          targets && (c.targets = targets);\n\t          i = queue.indexOf(f);\n\n\t          if (~i) {\n\t            queue.splice(i, 1);\n\t            queue.length || done();\n\t          }\n\t        };\n\n\t        queue.push(f);\n\t        c.vars.loadState(f);\n\t      }\n\t    });\n\t    queue.length || done();\n\t    return this;\n\t  };\n\n\t  _proto4.setState = function setState() {\n\t    this.actions.forEach(function (c) {\n\t      return c.targets = c.vars.setState && c.vars.setState(c);\n\t    });\n\t    return this;\n\t  };\n\n\t  _proto4.killConflicts = function killConflicts(soft) {\n\t    this.state.interrupt(soft);\n\n\t    this._kill.forEach(function (state) {\n\t      return state.interrupt(soft);\n\t    });\n\n\t    return this;\n\t  };\n\n\t  _proto4.run = function run(skipGetState, merge) {\n\t    var _this5 = this;\n\n\t    if (this !== _batch) {\n\t      skipGetState || this.getState(merge);\n\t      this.loadState(function () {\n\t        if (!_this5._killed) {\n\t          _this5.setState();\n\n\t          _this5.animate();\n\t        }\n\t      });\n\t    }\n\n\t    return this;\n\t  };\n\n\t  _proto4.clear = function clear(stateOnly) {\n\t    this.state.clear();\n\t    stateOnly || (this.actions.length = 0);\n\t  };\n\n\t  _proto4.getStateById = function getStateById(id) {\n\t    var i = this.actions.length,\n\t        s;\n\n\t    while (i--) {\n\t      s = this.actions[i].getStateById(id);\n\n\t      if (s) {\n\t        return s;\n\t      }\n\t    }\n\n\t    return this.state.idLookup[id] && this.state;\n\t  };\n\n\t  _proto4.kill = function kill() {\n\t    this._killed = 1;\n\t    this.clear();\n\t    delete _batchLookup[this.id];\n\t  };\n\n\t  return FlipBatch;\n\t}();\n\n\tvar Flip = function () {\n\t  function Flip() {}\n\n\t  Flip.getState = function getState(targets, vars) {\n\t    var state = _parseState(targets, vars);\n\n\t    _batchAction && _batchAction.states.push(state);\n\t    vars && vars.batch && Flip.batch(vars.batch).state.add(state);\n\t    return state;\n\t  };\n\n\t  Flip.from = function from(state, vars) {\n\t    vars = vars || {};\n\t    \"clearProps\" in vars || (vars.clearProps = true);\n\t    return _fromTo(state, _parseState(vars.targets || state.targets, {\n\t      props: vars.props || state.props,\n\t      simple: vars.simple,\n\t      kill: !!vars.kill\n\t    }), vars, -1);\n\t  };\n\n\t  Flip.to = function to(state, vars) {\n\t    return _fromTo(state, _parseState(vars.targets || state.targets, {\n\t      props: vars.props || state.props,\n\t      simple: vars.simple,\n\t      kill: !!vars.kill\n\t    }), vars, 1);\n\t  };\n\n\t  Flip.fromTo = function fromTo(fromState, toState, vars) {\n\t    return _fromTo(fromState, toState, vars);\n\t  };\n\n\t  Flip.fit = function fit(fromEl, toEl, vars) {\n\t    var v = vars ? _copy(vars, _fitReserved) : {},\n\t        _ref = vars || v,\n\t        absolute = _ref.absolute,\n\t        scale = _ref.scale,\n\t        getVars = _ref.getVars,\n\t        props = _ref.props,\n\t        runBackwards = _ref.runBackwards,\n\t        onComplete = _ref.onComplete,\n\t        simple = _ref.simple,\n\t        fitChild = vars && vars.fitChild && _getEl(vars.fitChild),\n\t        before = _parseElementState(toEl, props, simple, fromEl),\n\t        after = _parseElementState(fromEl, 0, simple, before),\n\t        inlineProps = props ? _memoizedRemoveProps[props] : _removeProps;\n\n\t    props && _applyProps(v, before.props);\n\n\t    if (runBackwards) {\n\t      _recordInlineStyles(after, inlineProps);\n\n\t      \"immediateRender\" in v || (v.immediateRender = true);\n\n\t      v.onComplete = function () {\n\t        _applyInlineStyles(after);\n\n\t        onComplete && onComplete.apply(this, arguments);\n\t      };\n\t    }\n\n\t    absolute && _makeAbsolute(after, before);\n\t    v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n\t    return getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n\t  };\n\n\t  Flip.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {\n\t    return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n\t  };\n\n\t  Flip.batch = function batch(id) {\n\t    id || (id = \"default\");\n\t    return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));\n\t  };\n\n\t  Flip.killFlipsOf = function killFlipsOf(targets, complete) {\n\t    (targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(function (t) {\n\t      return t && _killFlip(t._flip, complete !== false ? 1 : 2);\n\t    });\n\t  };\n\n\t  Flip.isFlipping = function isFlipping(target) {\n\t    var f = Flip.getByTarget(target);\n\t    return !!f && f.isActive();\n\t  };\n\n\t  Flip.getByTarget = function getByTarget(target) {\n\t    return (_getEl(target) || _emptyObj)._flip;\n\t  };\n\n\t  Flip.getElementState = function getElementState(target, props) {\n\t    return new ElementState(_getEl(target), props);\n\t  };\n\n\t  Flip.convertCoordinates = function convertCoordinates(fromElement, toElement, point) {\n\t    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n\t    return point ? m.apply(point) : m;\n\t  };\n\n\t  Flip.register = function register(core) {\n\t    _body$1 = typeof document !== \"undefined\" && document.body;\n\n\t    if (_body$1) {\n\t      gsap = core;\n\n\t      _setDoc(_body$1);\n\n\t      _toArray = gsap.utils.toArray;\n\t      var snap = gsap.utils.snap(0.1);\n\n\t      _closestTenth = function _closestTenth(value, add) {\n\t        return snap(parseFloat(value) + add);\n\t      };\n\t    }\n\t  };\n\n\t  return Flip;\n\t}();\n\tFlip.version = \"3.11.3\";\n\ttypeof window !== \"undefined\" && window.gsap && window.gsap.registerPlugin(Flip);\n\n\texports.Flip = Flip;\n\texports.default = Flip;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9kaXN0L0ZsaXAuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDdUU7QUFDeEUsQ0FBQyw2QkFBNkI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWMsb0JBQW9CLFNBQVMsVUFBVTtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGFBQWEsZ0JBQWdCOztBQUUzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRix3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxhQUFhOztBQUU3RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL2Rpc3QvRmxpcC5qcz8yN2QzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC53aW5kb3cgPSBnbG9iYWwud2luZG93IHx8IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0dmFyIF9kb2MsXG5cdCAgICBfd2luLFxuXHQgICAgX2RvY0VsZW1lbnQsXG5cdCAgICBfYm9keSxcblx0ICAgIF9kaXZDb250YWluZXIsXG5cdCAgICBfc3ZnQ29udGFpbmVyLFxuXHQgICAgX2lkZW50aXR5TWF0cml4LFxuXHQgICAgX2dFbCxcblx0ICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcblx0ICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuXHQgICAgX2hhc09mZnNldEJ1Zyxcblx0ICAgIF9zZXREb2MgPSBmdW5jdGlvbiBfc2V0RG9jKGVsZW1lbnQpIHtcblx0ICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG5cblx0ICBpZiAoIShfdHJhbnNmb3JtUHJvcCBpbiBlbGVtZW50LnN0eWxlKSAmJiBcIm1zVHJhbnNmb3JtXCIgaW4gZWxlbWVudC5zdHlsZSkge1xuXHQgICAgX3RyYW5zZm9ybVByb3AgPSBcIm1zVHJhbnNmb3JtXCI7XG5cdCAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcblx0ICB9XG5cblx0ICB3aGlsZSAoZG9jLnBhcmVudE5vZGUgJiYgKGRvYyA9IGRvYy5wYXJlbnROb2RlKSkge31cblxuXHQgIF93aW4gPSB3aW5kb3c7XG5cdCAgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDJEKCk7XG5cblx0ICBpZiAoZG9jKSB7XG5cdCAgICBfZG9jID0gZG9jO1xuXHQgICAgX2RvY0VsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHQgICAgX2JvZHkgPSBkb2MuYm9keTtcblx0ICAgIF9nRWwgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcblx0ICAgIF9nRWwuc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG5cdCAgICB2YXIgZDEgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0ICAgICAgICBkMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdCAgICBfYm9keS5hcHBlbmRDaGlsZChkMSk7XG5cblx0ICAgIGQxLmFwcGVuZENoaWxkKGQyKTtcblx0ICAgIGQxLnN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIjtcblx0ICAgIGQxLnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IFwidHJhbnNsYXRlM2QoMCwwLDFweClcIjtcblx0ICAgIF9oYXNPZmZzZXRCdWcgPSBkMi5vZmZzZXRQYXJlbnQgIT09IGQxO1xuXG5cdCAgICBfYm9keS5yZW1vdmVDaGlsZChkMSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRvYztcblx0fSxcblx0ICAgIF9mb3JjZU5vblplcm9TY2FsZSA9IGZ1bmN0aW9uIF9mb3JjZU5vblplcm9TY2FsZShlKSB7XG5cdCAgdmFyIGEsIGNhY2hlO1xuXG5cdCAgd2hpbGUgKGUgJiYgZSAhPT0gX2JvZHkpIHtcblx0ICAgIGNhY2hlID0gZS5fZ3NhcDtcblx0ICAgIGNhY2hlICYmIGNhY2hlLnVuY2FjaGUgJiYgY2FjaGUuZ2V0KGUsIFwieFwiKTtcblxuXHQgICAgaWYgKGNhY2hlICYmICFjYWNoZS5zY2FsZVggJiYgIWNhY2hlLnNjYWxlWSAmJiBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0pIHtcblx0ICAgICAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gMWUtNDtcblx0ICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGNhY2hlKTtcblx0ICAgICAgYSA/IGEucHVzaChjYWNoZSkgOiBhID0gW2NhY2hlXTtcblx0ICAgIH1cblxuXHQgICAgZSA9IGUucGFyZW50Tm9kZTtcblx0ICB9XG5cblx0ICByZXR1cm4gYTtcblx0fSxcblx0ICAgIF9zdmdUZW1wcyA9IFtdLFxuXHQgICAgX2RpdlRlbXBzID0gW10sXG5cdCAgICBfZ2V0RG9jU2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbFRvcCgpIHtcblx0ICByZXR1cm4gX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jLnNjcm9sbFRvcCB8fCBfZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDA7XG5cdH0sXG5cdCAgICBfZ2V0RG9jU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxMZWZ0KCkge1xuXHQgIHJldHVybiBfd2luLnBhZ2VYT2Zmc2V0IHx8IF9kb2Muc2Nyb2xsTGVmdCB8fCBfZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IF9ib2R5LnNjcm9sbExlZnQgfHwgMDtcblx0fSxcblx0ICAgIF9zdmdPd25lciA9IGZ1bmN0aW9uIF9zdmdPd25lcihlbGVtZW50KSB7XG5cdCAgcmV0dXJuIGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8ICgoZWxlbWVudC50YWdOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIiA/IGVsZW1lbnQgOiBudWxsKTtcblx0fSxcblx0ICAgIF9pc0ZpeGVkID0gZnVuY3Rpb24gX2lzRml4ZWQoZWxlbWVudCkge1xuXHQgIGlmIChfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuXHQgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcblx0ICAgIHJldHVybiBfaXNGaXhlZChlbGVtZW50KTtcblx0ICB9XG5cdH0sXG5cdCAgICBfY3JlYXRlU2libGluZyA9IGZ1bmN0aW9uIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIGkpIHtcblx0ICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpKSB7XG5cdCAgICB2YXIgc3ZnID0gX3N2Z093bmVyKGVsZW1lbnQpLFxuXHQgICAgICAgIG5zID0gc3ZnID8gc3ZnLmdldEF0dHJpYnV0ZShcInhtbG5zXCIpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiA6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuXHQgICAgICAgIHR5cGUgPSBzdmcgPyBpID8gXCJyZWN0XCIgOiBcImdcIiA6IFwiZGl2XCIsXG5cdCAgICAgICAgeCA9IGkgIT09IDIgPyAwIDogMTAwLFxuXHQgICAgICAgIHkgPSBpID09PSAzID8gMTAwIDogMCxcblx0ICAgICAgICBjc3MgPSBcInBvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7XCIsXG5cdCAgICAgICAgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMobnMucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcblxuXHQgICAgaWYgKGkpIHtcblx0ICAgICAgaWYgKCFzdmcpIHtcblx0ICAgICAgICBpZiAoIV9kaXZDb250YWluZXIpIHtcblx0ICAgICAgICAgIF9kaXZDb250YWluZXIgPSBfY3JlYXRlU2libGluZyhlbGVtZW50KTtcblx0ICAgICAgICAgIF9kaXZDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGNzcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBlLnN0eWxlLmNzc1RleHQgPSBjc3MgKyBcIndpZHRoOjAuMXB4O2hlaWdodDowLjFweDt0b3A6XCIgKyB5ICsgXCJweDtsZWZ0OlwiICsgeCArIFwicHhcIjtcblxuXHQgICAgICAgIF9kaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgX3N2Z0NvbnRhaW5lciB8fCAoX3N2Z0NvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpKTtcblx0ICAgICAgICBlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDAuMDEpO1xuXHQgICAgICAgIGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDAuMDEpO1xuXHQgICAgICAgIGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiKTtcblxuXHQgICAgICAgIF9zdmdDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGU7XG5cdCAgfVxuXG5cdCAgdGhyb3cgXCJOZWVkIGRvY3VtZW50IGFuZCBwYXJlbnQuXCI7XG5cdH0sXG5cdCAgICBfY29uc29saWRhdGUgPSBmdW5jdGlvbiBfY29uc29saWRhdGUobSkge1xuXHQgIHZhciBjID0gbmV3IE1hdHJpeDJEKCksXG5cdCAgICAgIGkgPSAwO1xuXG5cdCAgZm9yICg7IGkgPCBtLm51bWJlck9mSXRlbXM7IGkrKykge1xuXHQgICAgYy5tdWx0aXBseShtLmdldEl0ZW0oaSkubWF0cml4KTtcblx0ICB9XG5cblx0ICByZXR1cm4gYztcblx0fSxcblx0ICAgIF9nZXRDVE0gPSBmdW5jdGlvbiBfZ2V0Q1RNKHN2Zykge1xuXHQgIHZhciBtID0gc3ZnLmdldENUTSgpLFxuXHQgICAgICB0cmFuc2Zvcm07XG5cblx0ICBpZiAoIW0pIHtcblx0ICAgIHRyYW5zZm9ybSA9IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF07XG5cdCAgICBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJub25lXCI7XG5cdCAgICBzdmcuYXBwZW5kQ2hpbGQoX2dFbCk7XG5cdCAgICBtID0gX2dFbC5nZXRDVE0oKTtcblx0ICAgIHN2Zy5yZW1vdmVDaGlsZChfZ0VsKTtcblx0ICAgIHRyYW5zZm9ybSA/IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm0gOiBzdmcuc3R5bGUucmVtb3ZlUHJvcGVydHkoX3RyYW5zZm9ybVByb3AucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbSB8fCBfaWRlbnRpdHlNYXRyaXguY2xvbmUoKTtcblx0fSxcblx0ICAgIF9wbGFjZVNpYmxpbmdzID0gZnVuY3Rpb24gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCkge1xuXHQgIHZhciBzdmcgPSBfc3ZnT3duZXIoZWxlbWVudCksXG5cdCAgICAgIGlzUm9vdFNWRyA9IGVsZW1lbnQgPT09IHN2Zyxcblx0ICAgICAgc2libGluZ3MgPSBzdmcgPyBfc3ZnVGVtcHMgOiBfZGl2VGVtcHMsXG5cdCAgICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSxcblx0ICAgICAgY29udGFpbmVyLFxuXHQgICAgICBtLFxuXHQgICAgICBiLFxuXHQgICAgICB4LFxuXHQgICAgICB5LFxuXHQgICAgICBjcztcblxuXHQgIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG5cdCAgICByZXR1cm4gZWxlbWVudDtcblx0ICB9XG5cblx0ICBzaWJsaW5ncy5sZW5ndGggfHwgc2libGluZ3MucHVzaChfY3JlYXRlU2libGluZyhlbGVtZW50LCAxKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMiksIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDMpKTtcblx0ICBjb250YWluZXIgPSBzdmcgPyBfc3ZnQ29udGFpbmVyIDogX2RpdkNvbnRhaW5lcjtcblxuXHQgIGlmIChzdmcpIHtcblx0ICAgIGlmIChpc1Jvb3RTVkcpIHtcblx0ICAgICAgYiA9IF9nZXRDVE0oZWxlbWVudCk7XG5cdCAgICAgIHggPSAtYi5lIC8gYi5hO1xuXHQgICAgICB5ID0gLWIuZiAvIGIuZDtcblx0ICAgICAgbSA9IF9pZGVudGl0eU1hdHJpeDtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudC5nZXRCQm94KSB7XG5cdCAgICAgIGIgPSBlbGVtZW50LmdldEJCb3goKTtcblx0ICAgICAgbSA9IGVsZW1lbnQudHJhbnNmb3JtID8gZWxlbWVudC50cmFuc2Zvcm0uYmFzZVZhbCA6IHt9O1xuXHQgICAgICBtID0gIW0ubnVtYmVyT2ZJdGVtcyA/IF9pZGVudGl0eU1hdHJpeCA6IG0ubnVtYmVyT2ZJdGVtcyA+IDEgPyBfY29uc29saWRhdGUobSkgOiBtLmdldEl0ZW0oMCkubWF0cml4O1xuXHQgICAgICB4ID0gbS5hICogYi54ICsgbS5jICogYi55O1xuXHQgICAgICB5ID0gbS5iICogYi54ICsgbS5kICogYi55O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbSA9IG5ldyBNYXRyaXgyRCgpO1xuXHQgICAgICB4ID0geSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGlmIChhZGp1c3RHT2Zmc2V0ICYmIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImdcIikge1xuXHQgICAgICB4ID0geSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIChpc1Jvb3RTVkcgPyBzdmcgOiBwYXJlbnQpLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdCAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbS5hICsgXCIsXCIgKyBtLmIgKyBcIixcIiArIG0uYyArIFwiLFwiICsgbS5kICsgXCIsXCIgKyAobS5lICsgeCkgKyBcIixcIiArIChtLmYgKyB5KSArIFwiKVwiKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgeCA9IHkgPSAwO1xuXG5cdCAgICBpZiAoX2hhc09mZnNldEJ1Zykge1xuXHQgICAgICBtID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG5cdCAgICAgIGIgPSBlbGVtZW50O1xuXG5cdCAgICAgIHdoaWxlIChiICYmIChiID0gYi5wYXJlbnROb2RlKSAmJiBiICE9PSBtICYmIGIucGFyZW50Tm9kZSkge1xuXHQgICAgICAgIGlmICgoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGIpW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmxlbmd0aCA+IDQpIHtcblx0ICAgICAgICAgIHggPSBiLm9mZnNldExlZnQ7XG5cdCAgICAgICAgICB5ID0gYi5vZmZzZXRUb3A7XG5cdCAgICAgICAgICBiID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgY3MgPSBfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cblx0ICAgIGlmIChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiICYmIGNzLnBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcblx0ICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG5cdCAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50ICE9PSBtKSB7XG5cdCAgICAgICAgeCArPSBwYXJlbnQuc2Nyb2xsTGVmdCB8fCAwO1xuXHQgICAgICAgIHkgKz0gcGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuXHQgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGIgPSBjb250YWluZXIuc3R5bGU7XG5cdCAgICBiLnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIC0geSArIFwicHhcIjtcblx0ICAgIGIubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCAtIHggKyBcInB4XCI7XG5cdCAgICBiW190cmFuc2Zvcm1Qcm9wXSA9IGNzW190cmFuc2Zvcm1Qcm9wXTtcblx0ICAgIGJbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gY3NbX3RyYW5zZm9ybU9yaWdpblByb3BdO1xuXHQgICAgYi5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG5cdCAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0ICB9XG5cblx0ICByZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXHQgICAgX3NldE1hdHJpeCA9IGZ1bmN0aW9uIF9zZXRNYXRyaXgobSwgYSwgYiwgYywgZCwgZSwgZikge1xuXHQgIG0uYSA9IGE7XG5cdCAgbS5iID0gYjtcblx0ICBtLmMgPSBjO1xuXHQgIG0uZCA9IGQ7XG5cdCAgbS5lID0gZTtcblx0ICBtLmYgPSBmO1xuXHQgIHJldHVybiBtO1xuXHR9O1xuXG5cdHZhciBNYXRyaXgyRCA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBNYXRyaXgyRChhLCBiLCBjLCBkLCBlLCBmKSB7XG5cdCAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGIgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGMgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZCA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGQgPSAxO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGUgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZiA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGYgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBfc2V0TWF0cml4KHRoaXMsIGEsIGIsIGMsIGQsIGUsIGYpO1xuXHQgIH1cblxuXHQgIHZhciBfcHJvdG8gPSBNYXRyaXgyRC5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8uaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UoKSB7XG5cdCAgICB2YXIgYSA9IHRoaXMuYSxcblx0ICAgICAgICBiID0gdGhpcy5iLFxuXHQgICAgICAgIGMgPSB0aGlzLmMsXG5cdCAgICAgICAgZCA9IHRoaXMuZCxcblx0ICAgICAgICBlID0gdGhpcy5lLFxuXHQgICAgICAgIGYgPSB0aGlzLmYsXG5cdCAgICAgICAgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjIHx8IDFlLTEwO1xuXHQgICAgcmV0dXJuIF9zZXRNYXRyaXgodGhpcywgZCAvIGRldGVybWluYW50LCAtYiAvIGRldGVybWluYW50LCAtYyAvIGRldGVybWluYW50LCBhIC8gZGV0ZXJtaW5hbnQsIChjICogZiAtIGQgKiBlKSAvIGRldGVybWluYW50LCAtKGEgKiBmIC0gYiAqIGUpIC8gZGV0ZXJtaW5hbnQpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcblx0ICAgIHZhciBhID0gdGhpcy5hLFxuXHQgICAgICAgIGIgPSB0aGlzLmIsXG5cdCAgICAgICAgYyA9IHRoaXMuYyxcblx0ICAgICAgICBkID0gdGhpcy5kLFxuXHQgICAgICAgIGUgPSB0aGlzLmUsXG5cdCAgICAgICAgZiA9IHRoaXMuZixcblx0ICAgICAgICBhMiA9IG1hdHJpeC5hLFxuXHQgICAgICAgIGIyID0gbWF0cml4LmMsXG5cdCAgICAgICAgYzIgPSBtYXRyaXguYixcblx0ICAgICAgICBkMiA9IG1hdHJpeC5kLFxuXHQgICAgICAgIGUyID0gbWF0cml4LmUsXG5cdCAgICAgICAgZjIgPSBtYXRyaXguZjtcblx0ICAgIHJldHVybiBfc2V0TWF0cml4KHRoaXMsIGEyICogYSArIGMyICogYywgYTIgKiBiICsgYzIgKiBkLCBiMiAqIGEgKyBkMiAqIGMsIGIyICogYiArIGQyICogZCwgZSArIGUyICogYSArIGYyICogYywgZiArIGUyICogYiArIGYyICogZCk7XG5cdCAgfTtcblxuXHQgIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuXHQgICAgcmV0dXJuIG5ldyBNYXRyaXgyRCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMuZSwgdGhpcy5mKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhtYXRyaXgpIHtcblx0ICAgIHZhciBhID0gdGhpcy5hLFxuXHQgICAgICAgIGIgPSB0aGlzLmIsXG5cdCAgICAgICAgYyA9IHRoaXMuYyxcblx0ICAgICAgICBkID0gdGhpcy5kLFxuXHQgICAgICAgIGUgPSB0aGlzLmUsXG5cdCAgICAgICAgZiA9IHRoaXMuZjtcblx0ICAgIHJldHVybiBhID09PSBtYXRyaXguYSAmJiBiID09PSBtYXRyaXguYiAmJiBjID09PSBtYXRyaXguYyAmJiBkID09PSBtYXRyaXguZCAmJiBlID09PSBtYXRyaXguZSAmJiBmID09PSBtYXRyaXguZjtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkocG9pbnQsIGRlY29yYXRlZSkge1xuXHQgICAgaWYgKGRlY29yYXRlZSA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGRlY29yYXRlZSA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgeCA9IHBvaW50LngsXG5cdCAgICAgICAgeSA9IHBvaW50LnksXG5cdCAgICAgICAgYSA9IHRoaXMuYSxcblx0ICAgICAgICBiID0gdGhpcy5iLFxuXHQgICAgICAgIGMgPSB0aGlzLmMsXG5cdCAgICAgICAgZCA9IHRoaXMuZCxcblx0ICAgICAgICBlID0gdGhpcy5lLFxuXHQgICAgICAgIGYgPSB0aGlzLmY7XG5cdCAgICBkZWNvcmF0ZWUueCA9IHggKiBhICsgeSAqIGMgKyBlIHx8IDA7XG5cdCAgICBkZWNvcmF0ZWUueSA9IHggKiBiICsgeSAqIGQgKyBmIHx8IDA7XG5cdCAgICByZXR1cm4gZGVjb3JhdGVlO1xuXHQgIH07XG5cblx0ICByZXR1cm4gTWF0cml4MkQ7XG5cdH0oKTtcblx0ZnVuY3Rpb24gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGludmVyc2UsIGFkanVzdEdPZmZzZXQsIGluY2x1ZGVTY3JvbGxJbkZpeGVkKSB7XG5cdCAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudE5vZGUgfHwgKF9kb2MgfHwgX3NldERvYyhlbGVtZW50KSkuZG9jdW1lbnRFbGVtZW50ID09PSBlbGVtZW50KSB7XG5cdCAgICByZXR1cm4gbmV3IE1hdHJpeDJEKCk7XG5cdCAgfVxuXG5cdCAgdmFyIHplcm9TY2FsZXMgPSBfZm9yY2VOb25aZXJvU2NhbGUoZWxlbWVudCksXG5cdCAgICAgIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcblx0ICAgICAgdGVtcHMgPSBzdmcgPyBfc3ZnVGVtcHMgOiBfZGl2VGVtcHMsXG5cdCAgICAgIGNvbnRhaW5lciA9IF9wbGFjZVNpYmxpbmdzKGVsZW1lbnQsIGFkanVzdEdPZmZzZXQpLFxuXHQgICAgICBiMSA9IHRlbXBzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHQgICAgICBiMiA9IHRlbXBzWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHQgICAgICBiMyA9IHRlbXBzWzJdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHQgICAgICBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZSxcblx0ICAgICAgaXNGaXhlZCA9ICFpbmNsdWRlU2Nyb2xsSW5GaXhlZCAmJiBfaXNGaXhlZChlbGVtZW50KSxcblx0ICAgICAgbSA9IG5ldyBNYXRyaXgyRCgoYjIubGVmdCAtIGIxLmxlZnQpIC8gMTAwLCAoYjIudG9wIC0gYjEudG9wKSAvIDEwMCwgKGIzLmxlZnQgLSBiMS5sZWZ0KSAvIDEwMCwgKGIzLnRvcCAtIGIxLnRvcCkgLyAxMDAsIGIxLmxlZnQgKyAoaXNGaXhlZCA/IDAgOiBfZ2V0RG9jU2Nyb2xsTGVmdCgpKSwgYjEudG9wICsgKGlzRml4ZWQgPyAwIDogX2dldERvY1Njcm9sbFRvcCgpKSk7XG5cblx0ICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuXHQgIGlmICh6ZXJvU2NhbGVzKSB7XG5cdCAgICBiMSA9IHplcm9TY2FsZXMubGVuZ3RoO1xuXG5cdCAgICB3aGlsZSAoYjEtLSkge1xuXHQgICAgICBiMiA9IHplcm9TY2FsZXNbYjFdO1xuXHQgICAgICBiMi5zY2FsZVggPSBiMi5zY2FsZVkgPSAwO1xuXHQgICAgICBiMi5yZW5kZXJUcmFuc2Zvcm0oMSwgYjIpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBpbnZlcnNlID8gbS5pbnZlcnNlKCkgOiBtO1xuXHR9XG5cblx0LyohXG5cdCAqIEZsaXAgMy4xMS4zXG5cdCAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuXHQgKlxuXHQgKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuXHQgKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cblx0ICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG5cdCovXG5cblx0dmFyIF9pZCA9IDEsXG5cdCAgICBfdG9BcnJheSxcblx0ICAgIGdzYXAsXG5cdCAgICBfYmF0Y2gsXG5cdCAgICBfYmF0Y2hBY3Rpb24sXG5cdCAgICBfYm9keSQxLFxuXHQgICAgX2Nsb3Nlc3RUZW50aCxcblx0ICAgIF9mb3JFYWNoQmF0Y2ggPSBmdW5jdGlvbiBfZm9yRWFjaEJhdGNoKGJhdGNoLCBuYW1lKSB7XG5cdCAgcmV0dXJuIGJhdGNoLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuXHQgICAgcmV0dXJuIGEudmFyc1tuYW1lXSAmJiBhLnZhcnNbbmFtZV0oYSk7XG5cdCAgfSk7XG5cdH0sXG5cdCAgICBfYmF0Y2hMb29rdXAgPSB7fSxcblx0ICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0ICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0ICAgIF9lbXB0eU9iaiA9IHt9LFxuXHQgICAgX2Rhc2hlZE5hbWVMb29rdXAgPSB7fSxcblx0ICAgIF9tZW1vaXplZFJlbW92ZVByb3BzID0ge30sXG5cdCAgICBfbGlzdFRvQXJyYXkgPSBmdW5jdGlvbiBfbGlzdFRvQXJyYXkobGlzdCkge1xuXHQgIHJldHVybiB0eXBlb2YgbGlzdCA9PT0gXCJzdHJpbmdcIiA/IGxpc3Quc3BsaXQoXCIgXCIpLmpvaW4oXCJcIikuc3BsaXQoXCIsXCIpIDogbGlzdDtcblx0fSxcblx0ICAgIF9jYWxsYmFja3MgPSBfbGlzdFRvQXJyYXkoXCJvblN0YXJ0LG9uVXBkYXRlLG9uQ29tcGxldGUsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiksXG5cdCAgICBfcmVtb3ZlUHJvcHMgPSBfbGlzdFRvQXJyYXkoXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHdpZHRoLGhlaWdodCxwb3NpdGlvbix0b3AsbGVmdCxvcGFjaXR5LHpJbmRleCxtYXhXaWR0aCxtYXhIZWlnaHQsbWluV2lkdGgsbWluSGVpZ2h0XCIpLFxuXHQgICAgX2dldEVsID0gZnVuY3Rpb24gX2dldEVsKHRhcmdldCkge1xuXHQgIHJldHVybiBfdG9BcnJheSh0YXJnZXQpWzBdIHx8IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0YXJnZXQpO1xuXHR9LFxuXHQgICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG5cdCAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMCB8fCAwO1xuXHR9LFxuXHQgICAgX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gX3RvZ2dsZUNsYXNzKHRhcmdldHMsIGNsYXNzTmFtZSwgYWN0aW9uKSB7XG5cdCAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0ICAgIHJldHVybiBlbC5jbGFzc0xpc3RbYWN0aW9uXShjbGFzc05hbWUpO1xuXHQgIH0pO1xuXHR9LFxuXHQgICAgX3Jlc2VydmVkID0ge1xuXHQgIHpJbmRleDogMSxcblx0ICBraWxsOiAxLFxuXHQgIHNpbXBsZTogMSxcblx0ICBzcGluOiAxLFxuXHQgIGNsZWFyUHJvcHM6IDEsXG5cdCAgdGFyZ2V0czogMSxcblx0ICB0b2dnbGVDbGFzczogMSxcblx0ICBvbkNvbXBsZXRlOiAxLFxuXHQgIG9uVXBkYXRlOiAxLFxuXHQgIG9uSW50ZXJydXB0OiAxLFxuXHQgIG9uU3RhcnQ6IDEsXG5cdCAgZGVsYXk6IDEsXG5cdCAgcmVwZWF0OiAxLFxuXHQgIHJlcGVhdERlbGF5OiAxLFxuXHQgIHlveW86IDEsXG5cdCAgc2NhbGU6IDEsXG5cdCAgZmFkZTogMSxcblx0ICBhYnNvbHV0ZTogMSxcblx0ICBwcm9wczogMSxcblx0ICBvbkVudGVyOiAxLFxuXHQgIG9uTGVhdmU6IDEsXG5cdCAgY3VzdG9tOiAxLFxuXHQgIHBhdXNlZDogMSxcblx0ICBuZXN0ZWQ6IDEsXG5cdCAgcHJ1bmU6IDEsXG5cdCAgYWJzb2x1dGVPbkxlYXZlOiAxXG5cdH0sXG5cdCAgICBfZml0UmVzZXJ2ZWQgPSB7XG5cdCAgekluZGV4OiAxLFxuXHQgIHNpbXBsZTogMSxcblx0ICBjbGVhclByb3BzOiAxLFxuXHQgIHNjYWxlOiAxLFxuXHQgIGFic29sdXRlOiAxLFxuXHQgIGZpdENoaWxkOiAxLFxuXHQgIGdldFZhcnM6IDEsXG5cdCAgcHJvcHM6IDFcblx0fSxcblx0ICAgIF9jYW1lbFRvRGFzaGVkID0gZnVuY3Rpb24gX2NhbWVsVG9EYXNoZWQocCkge1xuXHQgIHJldHVybiBwLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcblx0fSxcblx0ICAgIF9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqLCBleGNsdWRlKSB7XG5cdCAgdmFyIHJlc3VsdCA9IHt9LFxuXHQgICAgICBwO1xuXG5cdCAgZm9yIChwIGluIG9iaikge1xuXHQgICAgZXhjbHVkZVtwXSB8fCAocmVzdWx0W3BdID0gb2JqW3BdKTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9LFxuXHQgICAgX21lbW9pemVkUHJvcHMgPSB7fSxcblx0ICAgIF9tZW1vaXplUHJvcHMgPSBmdW5jdGlvbiBfbWVtb2l6ZVByb3BzKHByb3BzKSB7XG5cdCAgdmFyIHAgPSBfbWVtb2l6ZWRQcm9wc1twcm9wc10gPSBfbGlzdFRvQXJyYXkocHJvcHMpO1xuXG5cdCAgX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdID0gcC5jb25jYXQoX3JlbW92ZVByb3BzKTtcblx0ICByZXR1cm4gcDtcblx0fSxcblx0ICAgIF9nZXRJbnZlcnNlR2xvYmFsTWF0cml4ID0gZnVuY3Rpb24gX2dldEludmVyc2VHbG9iYWxNYXRyaXgoZWwpIHtcblx0ICB2YXIgY2FjaGUgPSBlbC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWwpO1xuXG5cdCAgaWYgKGNhY2hlLmdtQ2FjaGUgPT09IGdzYXAudGlja2VyLmZyYW1lKSB7XG5cdCAgICByZXR1cm4gY2FjaGUuZ01hdHJpeDtcblx0ICB9XG5cblx0ICBjYWNoZS5nbUNhY2hlID0gZ3NhcC50aWNrZXIuZnJhbWU7XG5cdCAgcmV0dXJuIGNhY2hlLmdNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIHRydWUsIGZhbHNlLCB0cnVlKTtcblx0fSxcblx0ICAgIF9nZXRET01EZXB0aCA9IGZ1bmN0aW9uIF9nZXRET01EZXB0aChlbCwgaW52ZXJ0LCBsZXZlbCkge1xuXHQgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7XG5cdCAgICBsZXZlbCA9IDA7XG5cdCAgfVxuXG5cdCAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGUsXG5cdCAgICAgIGluYyA9IDEwMDAgKiBNYXRoLnBvdygxMCwgbGV2ZWwpICogKGludmVydCA/IC0xIDogMSksXG5cdCAgICAgIGwgPSBpbnZlcnQgPyAtaW5jICogOTAwIDogMDtcblxuXHQgIHdoaWxlIChlbCkge1xuXHQgICAgbCArPSBpbmM7XG5cdCAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcblx0ICB9XG5cblx0ICByZXR1cm4gcGFyZW50ID8gbCArIF9nZXRET01EZXB0aChwYXJlbnQsIGludmVydCwgbGV2ZWwgKyAxKSA6IGw7XG5cdH0sXG5cdCAgICBfb3JkZXJCeURPTURlcHRoID0gZnVuY3Rpb24gX29yZGVyQnlET01EZXB0aChjb21wcywgaW52ZXJ0LCBpc0VsU3RhdGVzKSB7XG5cdCAgY29tcHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcCkge1xuXHQgICAgcmV0dXJuIGNvbXAuZCA9IF9nZXRET01EZXB0aChpc0VsU3RhdGVzID8gY29tcC5lbGVtZW50IDogY29tcC50LCBpbnZlcnQpO1xuXHQgIH0pO1xuXHQgIGNvbXBzLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xuXHQgICAgcmV0dXJuIGMxLmQgLSBjMi5kO1xuXHQgIH0pO1xuXHQgIHJldHVybiBjb21wcztcblx0fSxcblx0ICAgIF9yZWNvcmRJbmxpbmVTdHlsZXMgPSBmdW5jdGlvbiBfcmVjb3JkSW5saW5lU3R5bGVzKGVsU3RhdGUsIHByb3BzKSB7XG5cdCAgdmFyIHN0eWxlID0gZWxTdGF0ZS5lbGVtZW50LnN0eWxlLFxuXHQgICAgICBhID0gZWxTdGF0ZS5jc3MgPSBlbFN0YXRlLmNzcyB8fCBbXSxcblx0ICAgICAgaSA9IHByb3BzLmxlbmd0aCxcblx0ICAgICAgcCxcblx0ICAgICAgdjtcblxuXHQgIHdoaWxlIChpLS0pIHtcblx0ICAgIHAgPSBwcm9wc1tpXTtcblx0ICAgIHYgPSBzdHlsZVtwXSB8fCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHApO1xuXHQgICAgYS5wdXNoKHYgPyBwIDogX2Rhc2hlZE5hbWVMb29rdXBbcF0gfHwgKF9kYXNoZWROYW1lTG9va3VwW3BdID0gX2NhbWVsVG9EYXNoZWQocCkpLCB2KTtcblx0ICB9XG5cblx0ICByZXR1cm4gc3R5bGU7XG5cdH0sXG5cdCAgICBfYXBwbHlJbmxpbmVTdHlsZXMgPSBmdW5jdGlvbiBfYXBwbHlJbmxpbmVTdHlsZXMoc3RhdGUpIHtcblx0ICB2YXIgY3NzID0gc3RhdGUuY3NzLFxuXHQgICAgICBzdHlsZSA9IHN0YXRlLmVsZW1lbnQuc3R5bGUsXG5cdCAgICAgIGkgPSAwO1xuXHQgIHN0YXRlLmNhY2hlLnVuY2FjaGUgPSAxO1xuXG5cdCAgZm9yICg7IGkgPCBjc3MubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIGNzc1tpICsgMV0gPyBzdHlsZVtjc3NbaV1dID0gY3NzW2kgKyAxXSA6IHN0eWxlLnJlbW92ZVByb3BlcnR5KGNzc1tpXSk7XG5cdCAgfVxuXHR9LFxuXHQgICAgX3NldEZpbmFsU3RhdGVzID0gZnVuY3Rpb24gX3NldEZpbmFsU3RhdGVzKGNvbXBzLCBvbmx5VHJhbnNmb3Jtcykge1xuXHQgIGNvbXBzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgIHJldHVybiBjLmEuY2FjaGUudW5jYWNoZSA9IDE7XG5cdCAgfSk7XG5cdCAgb25seVRyYW5zZm9ybXMgfHwgY29tcHMuZmluYWxTdGF0ZXMuZm9yRWFjaChfYXBwbHlJbmxpbmVTdHlsZXMpO1xuXHR9LFxuXHQgICAgX2Fic29sdXRlUHJvcHMgPSBcInBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20scGFkZGluZ0xlZnQsZ3JpZEFyZWEsdHJhbnNpdGlvblwiLnNwbGl0KFwiLFwiKSxcblx0ICAgIF9tYWtlQWJzb2x1dGUgPSBmdW5jdGlvbiBfbWFrZUFic29sdXRlKGVsU3RhdGUsIGZhbGxiYWNrTm9kZSwgaWdub3JlQmF0Y2gpIHtcblx0ICB2YXIgZWxlbWVudCA9IGVsU3RhdGUuZWxlbWVudCxcblx0ICAgICAgd2lkdGggPSBlbFN0YXRlLndpZHRoLFxuXHQgICAgICBoZWlnaHQgPSBlbFN0YXRlLmhlaWdodCxcblx0ICAgICAgdW5jYWNoZSA9IGVsU3RhdGUudW5jYWNoZSxcblx0ICAgICAgZ2V0UHJvcCA9IGVsU3RhdGUuZ2V0UHJvcCxcblx0ICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuXHQgICAgICBpID0gNCxcblx0ICAgICAgcmVzdWx0LFxuXHQgICAgICBkaXNwbGF5SXNOb25lLFxuXHQgICAgICBjcztcblx0ICB0eXBlb2YgZmFsbGJhY2tOb2RlICE9PSBcIm9iamVjdFwiICYmIChmYWxsYmFja05vZGUgPSBlbFN0YXRlKTtcblxuXHQgIGlmIChfYmF0Y2ggJiYgaWdub3JlQmF0Y2ggIT09IDEpIHtcblx0ICAgIF9iYXRjaC5fYWJzLnB1c2goe1xuXHQgICAgICB0OiBlbGVtZW50LFxuXHQgICAgICBiOiBlbFN0YXRlLFxuXHQgICAgICBhOiBlbFN0YXRlLFxuXHQgICAgICBzZDogMFxuXHQgICAgfSk7XG5cblx0ICAgIF9iYXRjaC5fZmluYWwucHVzaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiAoZWxTdGF0ZS5jYWNoZS51bmNhY2hlID0gMSkgJiYgX2FwcGx5SW5saW5lU3R5bGVzKGVsU3RhdGUpO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBlbGVtZW50O1xuXHQgIH1cblxuXHQgIGRpc3BsYXlJc05vbmUgPSBnZXRQcm9wKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCI7XG5cblx0ICBpZiAoIWVsU3RhdGUuaXNWaXNpYmxlIHx8IGRpc3BsYXlJc05vbmUpIHtcblx0ICAgIGRpc3BsYXlJc05vbmUgJiYgKF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgW1wiZGlzcGxheVwiXSkuZGlzcGxheSA9IGZhbGxiYWNrTm9kZS5kaXNwbGF5KTtcblx0ICAgIGVsU3RhdGUubWF0cml4ID0gZmFsbGJhY2tOb2RlLm1hdHJpeDtcblx0ICAgIGVsU3RhdGUud2lkdGggPSB3aWR0aCA9IGVsU3RhdGUud2lkdGggfHwgZmFsbGJhY2tOb2RlLndpZHRoO1xuXHQgICAgZWxTdGF0ZS5oZWlnaHQgPSBoZWlnaHQgPSBlbFN0YXRlLmhlaWdodCB8fCBmYWxsYmFja05vZGUuaGVpZ2h0O1xuXHQgIH1cblxuXHQgIF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgX2Fic29sdXRlUHJvcHMpO1xuXG5cdCAgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuXHQgIHdoaWxlIChpLS0pIHtcblx0ICAgIHN0eWxlW19hYnNvbHV0ZVByb3BzW2ldXSA9IGNzW19hYnNvbHV0ZVByb3BzW2ldXTtcblx0ICB9XG5cblx0ICBzdHlsZS5ncmlkQXJlYSA9IFwiMSAvIDEgLyAxIC8gMVwiO1xuXHQgIHN0eWxlLnRyYW5zaXRpb24gPSBcIm5vbmVcIjtcblx0ICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0ICBzdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuXHQgIHN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcblx0ICBzdHlsZS50b3AgfHwgKHN0eWxlLnRvcCA9IFwiMHB4XCIpO1xuXHQgIHN0eWxlLmxlZnQgfHwgKHN0eWxlLmxlZnQgPSBcIjBweFwiKTtcblxuXHQgIGlmICh1bmNhY2hlKSB7XG5cdCAgICByZXN1bHQgPSBuZXcgRWxlbWVudFN0YXRlKGVsZW1lbnQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXN1bHQgPSBfY29weShlbFN0YXRlLCBfZW1wdHlPYmopO1xuXHQgICAgcmVzdWx0LnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG5cdCAgICBpZiAoZWxTdGF0ZS5zaW1wbGUpIHtcblx0ICAgICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdCAgICAgIHJlc3VsdC5tYXRyaXggPSBuZXcgTWF0cml4MkQoMSwgMCwgMCwgMSwgYm91bmRzLmxlZnQgKyBfZ2V0RG9jU2Nyb2xsTGVmdCgpLCBib3VuZHMudG9wICsgX2dldERvY1Njcm9sbFRvcCgpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdC5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXN1bHQgPSBfZml0KHJlc3VsdCwgZWxTdGF0ZSwgdHJ1ZSk7XG5cdCAgZWxTdGF0ZS54ID0gX2Nsb3Nlc3RUZW50aChyZXN1bHQueCwgMC4wMSk7XG5cdCAgZWxTdGF0ZS55ID0gX2Nsb3Nlc3RUZW50aChyZXN1bHQueSwgMC4wMSk7XG5cdCAgcmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cdCAgICBfZmlsdGVyQ29tcHMgPSBmdW5jdGlvbiBfZmlsdGVyQ29tcHMoY29tcHMsIHRhcmdldHMpIHtcblx0ICBpZiAodGFyZ2V0cyAhPT0gdHJ1ZSkge1xuXHQgICAgdGFyZ2V0cyA9IF90b0FycmF5KHRhcmdldHMpO1xuXHQgICAgY29tcHMgPSBjb21wcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgaWYgKHRhcmdldHMuaW5kZXhPZigoYy5zZCA8IDAgPyBjLmIgOiBjLmEpLmVsZW1lbnQpICE9PSAtMSkge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGMudC5fZ3NhcC5yZW5kZXJUcmFuc2Zvcm0oMSk7XG5cblx0ICAgICAgICBpZiAoYy5iLmlzVmlzaWJsZSkge1xuXHQgICAgICAgICAgYy50LnN0eWxlLndpZHRoID0gYy5iLndpZHRoICsgXCJweFwiO1xuXHQgICAgICAgICAgYy50LnN0eWxlLmhlaWdodCA9IGMuYi5oZWlnaHQgKyBcInB4XCI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICByZXR1cm4gY29tcHM7XG5cdH0sXG5cdCAgICBfbWFrZUNvbXBzQWJzb2x1dGUgPSBmdW5jdGlvbiBfbWFrZUNvbXBzQWJzb2x1dGUoY29tcHMpIHtcblx0ICByZXR1cm4gX29yZGVyQnlET01EZXB0aChjb21wcywgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgcmV0dXJuIChjLmEuaXNWaXNpYmxlIHx8IGMuYi5pc1Zpc2libGUpICYmIF9tYWtlQWJzb2x1dGUoYy5zZCA8IDAgPyBjLmIgOiBjLmEsIGMuYiwgMSk7XG5cdCAgfSk7XG5cdH0sXG5cdCAgICBfZmluZEVsU3RhdGVJblN0YXRlID0gZnVuY3Rpb24gX2ZpbmRFbFN0YXRlSW5TdGF0ZShzdGF0ZSwgb3RoZXIpIHtcblx0ICByZXR1cm4gb3RoZXIgJiYgc3RhdGUuaWRMb29rdXBbX3BhcnNlRWxlbWVudFN0YXRlKG90aGVyKS5pZF0gfHwgc3RhdGUuZWxlbWVudFN0YXRlc1swXTtcblx0fSxcblx0ICAgIF9wYXJzZUVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIF9wYXJzZUVsZW1lbnRTdGF0ZShlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSwgb3RoZXIpIHtcblx0ICByZXR1cm4gZWxPck5vZGUgaW5zdGFuY2VvZiBFbGVtZW50U3RhdGUgPyBlbE9yTm9kZSA6IGVsT3JOb2RlIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gX2ZpbmRFbFN0YXRlSW5TdGF0ZShlbE9yTm9kZSwgb3RoZXIpIDogbmV3IEVsZW1lbnRTdGF0ZSh0eXBlb2YgZWxPck5vZGUgPT09IFwic3RyaW5nXCIgPyBfZ2V0RWwoZWxPck5vZGUpIHx8IGNvbnNvbGUud2FybihlbE9yTm9kZSArIFwiIG5vdCBmb3VuZFwiKSA6IGVsT3JOb2RlLCBwcm9wcywgc2ltcGxlKTtcblx0fSxcblx0ICAgIF9yZWNvcmRQcm9wcyA9IGZ1bmN0aW9uIF9yZWNvcmRQcm9wcyhlbFN0YXRlLCBwcm9wcykge1xuXHQgIHZhciBnZXRQcm9wID0gZ3NhcC5nZXRQcm9wZXJ0eShlbFN0YXRlLmVsZW1lbnQsIG51bGwsIFwibmF0aXZlXCIpLFxuXHQgICAgICBvYmogPSBlbFN0YXRlLnByb3BzID0ge30sXG5cdCAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICBvYmpbcHJvcHNbaV1dID0gKGdldFByb3AocHJvcHNbaV0pICsgXCJcIikudHJpbSgpO1xuXHQgIH1cblxuXHQgIG9iai56SW5kZXggJiYgKG9iai56SW5kZXggPSBwYXJzZUZsb2F0KG9iai56SW5kZXgpIHx8IDApO1xuXHQgIHJldHVybiBlbFN0YXRlO1xuXHR9LFxuXHQgICAgX2FwcGx5UHJvcHMgPSBmdW5jdGlvbiBfYXBwbHlQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuXHQgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUgfHwgZWxlbWVudCxcblx0ICAgICAgcDtcblxuXHQgIGZvciAocCBpbiBwcm9wcykge1xuXHQgICAgc3R5bGVbcF0gPSBwcm9wc1twXTtcblx0ICB9XG5cdH0sXG5cdCAgICBfZ2V0SUQgPSBmdW5jdGlvbiBfZ2V0SUQoZWwpIHtcblx0ICB2YXIgaWQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWZsaXAtaWRcIik7XG5cdCAgaWQgfHwgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1mbGlwLWlkXCIsIGlkID0gXCJhdXRvLVwiICsgX2lkKyspO1xuXHQgIHJldHVybiBpZDtcblx0fSxcblx0ICAgIF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzID0gZnVuY3Rpb24gX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMoZWxTdGF0ZXMpIHtcblx0ICByZXR1cm4gZWxTdGF0ZXMubWFwKGZ1bmN0aW9uIChlbFN0YXRlKSB7XG5cdCAgICByZXR1cm4gZWxTdGF0ZS5lbGVtZW50O1xuXHQgIH0pO1xuXHR9LFxuXHQgICAgX2hhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gX2hhbmRsZUNhbGxiYWNrKGNhbGxiYWNrLCBlbFN0YXRlcywgdGwpIHtcblx0ICByZXR1cm4gY2FsbGJhY2sgJiYgZWxTdGF0ZXMubGVuZ3RoICYmIHRsLmFkZChjYWxsYmFjayhfZWxlbWVudHNGcm9tRWxlbWVudFN0YXRlcyhlbFN0YXRlcyksIHRsLCBuZXcgRmxpcFN0YXRlKGVsU3RhdGVzLCAwLCB0cnVlKSksIDApO1xuXHR9LFxuXHQgICAgX2ZpdCA9IGZ1bmN0aW9uIF9maXQoZnJvbVN0YXRlLCB0b1N0YXRlLCBzY2FsZSwgYXBwbHlQcm9wcywgZml0Q2hpbGQsIHZhcnMpIHtcblx0ICB2YXIgZWxlbWVudCA9IGZyb21TdGF0ZS5lbGVtZW50LFxuXHQgICAgICBjYWNoZSA9IGZyb21TdGF0ZS5jYWNoZSxcblx0ICAgICAgcGFyZW50ID0gZnJvbVN0YXRlLnBhcmVudCxcblx0ICAgICAgeCA9IGZyb21TdGF0ZS54LFxuXHQgICAgICB5ID0gZnJvbVN0YXRlLnksXG5cdCAgICAgIHdpZHRoID0gdG9TdGF0ZS53aWR0aCxcblx0ICAgICAgaGVpZ2h0ID0gdG9TdGF0ZS5oZWlnaHQsXG5cdCAgICAgIHNjYWxlWCA9IHRvU3RhdGUuc2NhbGVYLFxuXHQgICAgICBzY2FsZVkgPSB0b1N0YXRlLnNjYWxlWSxcblx0ICAgICAgcm90YXRpb24gPSB0b1N0YXRlLnJvdGF0aW9uLFxuXHQgICAgICBib3VuZHMgPSB0b1N0YXRlLmJvdW5kcyxcblx0ICAgICAgY3NzVGV4dCA9IHZhcnMgJiYgZWxlbWVudC5zdHlsZS5jc3NUZXh0LFxuXHQgICAgICB0cmFuc2Zvcm0gPSB2YXJzICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSxcblx0ICAgICAgZGltZW5zaW9uU3RhdGUgPSBmcm9tU3RhdGUsXG5cdCAgICAgIF90b1N0YXRlJG1hdHJpeCA9IHRvU3RhdGUubWF0cml4LFxuXHQgICAgICBlID0gX3RvU3RhdGUkbWF0cml4LmUsXG5cdCAgICAgIGYgPSBfdG9TdGF0ZSRtYXRyaXguZixcblx0ICAgICAgZGVlcCA9IGZyb21TdGF0ZS5ib3VuZHMud2lkdGggIT09IGJvdW5kcy53aWR0aCB8fCBmcm9tU3RhdGUuYm91bmRzLmhlaWdodCAhPT0gYm91bmRzLmhlaWdodCB8fCBmcm9tU3RhdGUuc2NhbGVYICE9PSBzY2FsZVggfHwgZnJvbVN0YXRlLnNjYWxlWSAhPT0gc2NhbGVZIHx8IGZyb21TdGF0ZS5yb3RhdGlvbiAhPT0gcm90YXRpb24sXG5cdCAgICAgIHNpbXBsZSA9ICFkZWVwICYmIGZyb21TdGF0ZS5zaW1wbGUgJiYgdG9TdGF0ZS5zaW1wbGUgJiYgIWZpdENoaWxkLFxuXHQgICAgICBza2V3WCxcblx0ICAgICAgZnJvbVBvaW50LFxuXHQgICAgICB0b1BvaW50LFxuXHQgICAgICBnZXRQcm9wLFxuXHQgICAgICBwYXJlbnRNYXRyaXgsXG5cdCAgICAgIG1hdHJpeCxcblx0ICAgICAgYmJveDtcblxuXHQgIGlmIChzaW1wbGUgfHwgIXBhcmVudCkge1xuXHQgICAgc2NhbGVYID0gc2NhbGVZID0gMTtcblx0ICAgIHJvdGF0aW9uID0gc2tld1ggPSAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBwYXJlbnRNYXRyaXggPSBfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeChwYXJlbnQpO1xuXHQgICAgbWF0cml4ID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkodG9TdGF0ZS5jdG0gPyB0b1N0YXRlLm1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRvU3RhdGUuY3RtKSA6IHRvU3RhdGUubWF0cml4KTtcblx0ICAgIHJvdGF0aW9uID0gX3JvdW5kKE1hdGguYXRhbjIobWF0cml4LmIsIG1hdHJpeC5hKSAqIF9SQUQyREVHKTtcblx0ICAgIHNrZXdYID0gX3JvdW5kKE1hdGguYXRhbjIobWF0cml4LmMsIG1hdHJpeC5kKSAqIF9SQUQyREVHICsgcm90YXRpb24pICUgMzYwO1xuXHQgICAgc2NhbGVYID0gTWF0aC5zcXJ0KE1hdGgucG93KG1hdHJpeC5hLCAyKSArIE1hdGgucG93KG1hdHJpeC5iLCAyKSk7XG5cdCAgICBzY2FsZVkgPSBNYXRoLnNxcnQoTWF0aC5wb3cobWF0cml4LmMsIDIpICsgTWF0aC5wb3cobWF0cml4LmQsIDIpKSAqIE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpO1xuXG5cdCAgICBpZiAoZml0Q2hpbGQpIHtcblx0ICAgICAgZml0Q2hpbGQgPSBfdG9BcnJheShmaXRDaGlsZClbMF07XG5cdCAgICAgIGdldFByb3AgPSBnc2FwLmdldFByb3BlcnR5KGZpdENoaWxkKTtcblx0ICAgICAgYmJveCA9IGZpdENoaWxkLmdldEJCb3ggJiYgdHlwZW9mIGZpdENoaWxkLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIiAmJiBmaXRDaGlsZC5nZXRCQm94KCk7XG5cdCAgICAgIGRpbWVuc2lvblN0YXRlID0ge1xuXHQgICAgICAgIHNjYWxlWDogZ2V0UHJvcChcInNjYWxlWFwiKSxcblx0ICAgICAgICBzY2FsZVk6IGdldFByb3AoXCJzY2FsZVlcIiksXG5cdCAgICAgICAgd2lkdGg6IGJib3ggPyBiYm94LndpZHRoIDogTWF0aC5jZWlsKHBhcnNlRmxvYXQoZ2V0UHJvcChcIndpZHRoXCIsIFwicHhcIikpKSxcblx0ICAgICAgICBoZWlnaHQ6IGJib3ggPyBiYm94LmhlaWdodCA6IHBhcnNlRmxvYXQoZ2V0UHJvcChcImhlaWdodFwiLCBcInB4XCIpKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBjYWNoZS5yb3RhdGlvbiA9IHJvdGF0aW9uICsgXCJkZWdcIjtcblx0ICAgIGNhY2hlLnNrZXdYID0gc2tld1ggKyBcImRlZ1wiO1xuXHQgIH1cblxuXHQgIGlmIChzY2FsZSkge1xuXHQgICAgc2NhbGVYICo9IHdpZHRoID09PSBkaW1lbnNpb25TdGF0ZS53aWR0aCB8fCAhZGltZW5zaW9uU3RhdGUud2lkdGggPyAxIDogd2lkdGggLyBkaW1lbnNpb25TdGF0ZS53aWR0aDtcblx0ICAgIHNjYWxlWSAqPSBoZWlnaHQgPT09IGRpbWVuc2lvblN0YXRlLmhlaWdodCB8fCAhZGltZW5zaW9uU3RhdGUuaGVpZ2h0ID8gMSA6IGhlaWdodCAvIGRpbWVuc2lvblN0YXRlLmhlaWdodDtcblx0ICAgIGNhY2hlLnNjYWxlWCA9IHNjYWxlWDtcblx0ICAgIGNhY2hlLnNjYWxlWSA9IHNjYWxlWTtcblx0ICB9IGVsc2Uge1xuXHQgICAgd2lkdGggPSBfY2xvc2VzdFRlbnRoKHdpZHRoICogc2NhbGVYIC8gZGltZW5zaW9uU3RhdGUuc2NhbGVYLCAwKTtcblx0ICAgIGhlaWdodCA9IF9jbG9zZXN0VGVudGgoaGVpZ2h0ICogc2NhbGVZIC8gZGltZW5zaW9uU3RhdGUuc2NhbGVZLCAwKTtcblx0ICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcblx0ICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuXHQgIH1cblxuXHQgIGFwcGx5UHJvcHMgJiYgX2FwcGx5UHJvcHMoZWxlbWVudCwgdG9TdGF0ZS5wcm9wcyk7XG5cblx0ICBpZiAoc2ltcGxlIHx8ICFwYXJlbnQpIHtcblx0ICAgIHggKz0gZSAtIGZyb21TdGF0ZS5tYXRyaXguZTtcblx0ICAgIHkgKz0gZiAtIGZyb21TdGF0ZS5tYXRyaXguZjtcblx0ICB9IGVsc2UgaWYgKGRlZXAgfHwgcGFyZW50ICE9PSB0b1N0YXRlLnBhcmVudCkge1xuXHQgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGNhY2hlKTtcblx0ICAgIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChmaXRDaGlsZCB8fCBlbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuXHQgICAgZnJvbVBvaW50ID0gcGFyZW50TWF0cml4LmFwcGx5KHtcblx0ICAgICAgeDogbWF0cml4LmUsXG5cdCAgICAgIHk6IG1hdHJpeC5mXG5cdCAgICB9KTtcblx0ICAgIHRvUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuXHQgICAgICB4OiBlLFxuXHQgICAgICB5OiBmXG5cdCAgICB9KTtcblx0ICAgIHggKz0gdG9Qb2ludC54IC0gZnJvbVBvaW50Lng7XG5cdCAgICB5ICs9IHRvUG9pbnQueSAtIGZyb21Qb2ludC55O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBwYXJlbnRNYXRyaXguZSA9IHBhcmVudE1hdHJpeC5mID0gMDtcblx0ICAgIHRvUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuXHQgICAgICB4OiBlIC0gZnJvbVN0YXRlLm1hdHJpeC5lLFxuXHQgICAgICB5OiBmIC0gZnJvbVN0YXRlLm1hdHJpeC5mXG5cdCAgICB9KTtcblx0ICAgIHggKz0gdG9Qb2ludC54O1xuXHQgICAgeSArPSB0b1BvaW50Lnk7XG5cdCAgfVxuXG5cdCAgeCA9IF9jbG9zZXN0VGVudGgoeCwgMC4wMik7XG5cdCAgeSA9IF9jbG9zZXN0VGVudGgoeSwgMC4wMik7XG5cblx0ICBpZiAodmFycyAmJiAhKHZhcnMgaW5zdGFuY2VvZiBFbGVtZW50U3RhdGUpKSB7XG5cdCAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0O1xuXHQgICAgZWxlbWVudC5nZXRCQm94ICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB8fCBcIlwiKTtcblx0ICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjYWNoZS54ID0geCArIFwicHhcIjtcblx0ICAgIGNhY2hlLnkgPSB5ICsgXCJweFwiO1xuXHQgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGNhY2hlKTtcblx0ICB9XG5cblx0ICBpZiAodmFycykge1xuXHQgICAgdmFycy54ID0geDtcblx0ICAgIHZhcnMueSA9IHk7XG5cdCAgICB2YXJzLnJvdGF0aW9uID0gcm90YXRpb247XG5cdCAgICB2YXJzLnNrZXdYID0gc2tld1g7XG5cblx0ICAgIGlmIChzY2FsZSkge1xuXHQgICAgICB2YXJzLnNjYWxlWCA9IHNjYWxlWDtcblx0ICAgICAgdmFycy5zY2FsZVkgPSBzY2FsZVk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXJzLndpZHRoID0gd2lkdGg7XG5cdCAgICAgIHZhcnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB2YXJzIHx8IGNhY2hlO1xuXHR9LFxuXHQgICAgX3BhcnNlU3RhdGUgPSBmdW5jdGlvbiBfcGFyc2VTdGF0ZSh0YXJnZXRzT3JTdGF0ZSwgdmFycykge1xuXHQgIHJldHVybiB0YXJnZXRzT3JTdGF0ZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IHRhcmdldHNPclN0YXRlIDogbmV3IEZsaXBTdGF0ZSh0YXJnZXRzT3JTdGF0ZSwgdmFycyk7XG5cdH0sXG5cdCAgICBfZ2V0Q2hhbmdpbmdFbFN0YXRlID0gZnVuY3Rpb24gX2dldENoYW5naW5nRWxTdGF0ZSh0b1N0YXRlLCBmcm9tU3RhdGUsIGlkKSB7XG5cdCAgdmFyIHRvMSA9IHRvU3RhdGUuaWRMb29rdXBbaWRdLFxuXHQgICAgICB0bzIgPSB0b1N0YXRlLmFsdFtpZF07XG5cdCAgcmV0dXJuIHRvMi5pc1Zpc2libGUgJiYgKCEoZnJvbVN0YXRlLmdldEVsZW1lbnRTdGF0ZSh0bzIuZWxlbWVudCkgfHwgdG8yKS5pc1Zpc2libGUgfHwgIXRvMS5pc1Zpc2libGUpID8gdG8yIDogdG8xO1xuXHR9LFxuXHQgICAgX2JvZHlNZXRyaWNzID0gW10sXG5cdCAgICBfYm9keVByb3BzID0gXCJ3aWR0aCxoZWlnaHQsb3ZlcmZsb3dYLG92ZXJmbG93WVwiLnNwbGl0KFwiLFwiKSxcblx0ICAgIF9ib2R5TG9ja2VkLFxuXHQgICAgX2xvY2tCb2R5U2Nyb2xsID0gZnVuY3Rpb24gX2xvY2tCb2R5U2Nyb2xsKGxvY2spIHtcblx0ICBpZiAobG9jayAhPT0gX2JvZHlMb2NrZWQpIHtcblx0ICAgIHZhciBzID0gX2JvZHkkMS5zdHlsZSxcblx0ICAgICAgICB3ID0gX2JvZHkkMS5jbGllbnRXaWR0aCA9PT0gd2luZG93Lm91dGVyV2lkdGgsXG5cdCAgICAgICAgaCA9IF9ib2R5JDEuY2xpZW50SGVpZ2h0ID09PSB3aW5kb3cub3V0ZXJIZWlnaHQsXG5cdCAgICAgICAgaSA9IDQ7XG5cblx0ICAgIGlmIChsb2NrICYmICh3IHx8IGgpKSB7XG5cdCAgICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgICBfYm9keU1ldHJpY3NbaV0gPSBzW19ib2R5UHJvcHNbaV1dO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHcpIHtcblx0ICAgICAgICBzLndpZHRoID0gX2JvZHkkMS5jbGllbnRXaWR0aCArIFwicHhcIjtcblx0ICAgICAgICBzLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaCkge1xuXHQgICAgICAgIHMuaGVpZ2h0ID0gX2JvZHkkMS5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG5cdCAgICAgICAgcy5vdmVyZmxvd1ggPSBcImhpZGRlblwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgX2JvZHlMb2NrZWQgPSBsb2NrO1xuXHQgICAgfSBlbHNlIGlmIChfYm9keUxvY2tlZCkge1xuXHQgICAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgICAgX2JvZHlNZXRyaWNzW2ldID8gc1tfYm9keVByb3BzW2ldXSA9IF9ib2R5TWV0cmljc1tpXSA6IHMucmVtb3ZlUHJvcGVydHkoX2NhbWVsVG9EYXNoZWQoX2JvZHlQcm9wc1tpXSkpO1xuXHQgICAgICB9XG5cblx0ICAgICAgX2JvZHlMb2NrZWQgPSBsb2NrO1xuXHQgICAgfVxuXHQgIH1cblx0fSxcblx0ICAgIF9mcm9tVG8gPSBmdW5jdGlvbiBfZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycywgcmVsYXRpdmUpIHtcblx0ICBmcm9tU3RhdGUgaW5zdGFuY2VvZiBGbGlwU3RhdGUgJiYgdG9TdGF0ZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSB8fCBjb25zb2xlLndhcm4oXCJOb3QgYSB2YWxpZCBzdGF0ZSBvYmplY3QuXCIpO1xuXHQgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG5cdCAgdmFyIF92YXJzID0gdmFycyxcblx0ICAgICAgY2xlYXJQcm9wcyA9IF92YXJzLmNsZWFyUHJvcHMsXG5cdCAgICAgIG9uRW50ZXIgPSBfdmFycy5vbkVudGVyLFxuXHQgICAgICBvbkxlYXZlID0gX3ZhcnMub25MZWF2ZSxcblx0ICAgICAgYWJzb2x1dGUgPSBfdmFycy5hYnNvbHV0ZSxcblx0ICAgICAgYWJzb2x1dGVPbkxlYXZlID0gX3ZhcnMuYWJzb2x1dGVPbkxlYXZlLFxuXHQgICAgICBjdXN0b20gPSBfdmFycy5jdXN0b20sXG5cdCAgICAgIGRlbGF5ID0gX3ZhcnMuZGVsYXksXG5cdCAgICAgIHBhdXNlZCA9IF92YXJzLnBhdXNlZCxcblx0ICAgICAgcmVwZWF0ID0gX3ZhcnMucmVwZWF0LFxuXHQgICAgICByZXBlYXREZWxheSA9IF92YXJzLnJlcGVhdERlbGF5LFxuXHQgICAgICB5b3lvID0gX3ZhcnMueW95byxcblx0ICAgICAgdG9nZ2xlQ2xhc3MgPSBfdmFycy50b2dnbGVDbGFzcyxcblx0ICAgICAgbmVzdGVkID0gX3ZhcnMubmVzdGVkLFxuXHQgICAgICBfekluZGV4ID0gX3ZhcnMuekluZGV4LFxuXHQgICAgICBzY2FsZSA9IF92YXJzLnNjYWxlLFxuXHQgICAgICBmYWRlID0gX3ZhcnMuZmFkZSxcblx0ICAgICAgc3RhZ2dlciA9IF92YXJzLnN0YWdnZXIsXG5cdCAgICAgIHNwaW4gPSBfdmFycy5zcGluLFxuXHQgICAgICBwcnVuZSA9IF92YXJzLnBydW5lLFxuXHQgICAgICBwcm9wcyA9IChcInByb3BzXCIgaW4gdmFycyA/IHZhcnMgOiBmcm9tU3RhdGUpLnByb3BzLFxuXHQgICAgICB0d2VlblZhcnMgPSBfY29weSh2YXJzLCBfcmVzZXJ2ZWQpLFxuXHQgICAgICBhbmltYXRpb24gPSBnc2FwLnRpbWVsaW5lKHtcblx0ICAgIGRlbGF5OiBkZWxheSxcblx0ICAgIHBhdXNlZDogcGF1c2VkLFxuXHQgICAgcmVwZWF0OiByZXBlYXQsXG5cdCAgICByZXBlYXREZWxheTogcmVwZWF0RGVsYXksXG5cdCAgICB5b3lvOiB5b3lvLFxuXHQgICAgZGF0YTogXCJpc0ZsaXBcIlxuXHQgIH0pLFxuXHQgICAgICByZW1haW5pbmdQcm9wcyA9IHR3ZWVuVmFycyxcblx0ICAgICAgZW50ZXJpbmcgPSBbXSxcblx0ICAgICAgbGVhdmluZyA9IFtdLFxuXHQgICAgICBjb21wcyA9IFtdLFxuXHQgICAgICBzd2FwT3V0VGFyZ2V0cyA9IFtdLFxuXHQgICAgICBzcGluTnVtID0gc3BpbiA9PT0gdHJ1ZSA/IDEgOiBzcGluIHx8IDAsXG5cdCAgICAgIHNwaW5GdW5jID0gdHlwZW9mIHNwaW4gPT09IFwiZnVuY3Rpb25cIiA/IHNwaW4gOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gc3Bpbk51bTtcblx0ICB9LFxuXHQgICAgICBpbnRlcnJ1cHRlZCA9IGZyb21TdGF0ZS5pbnRlcnJ1cHRlZCB8fCB0b1N0YXRlLmludGVycnVwdGVkLFxuXHQgICAgICBhZGRGdW5jID0gYW5pbWF0aW9uW3JlbGF0aXZlICE9PSAxID8gXCJ0b1wiIDogXCJmcm9tXCJdLFxuXHQgICAgICB2LFxuXHQgICAgICBwLFxuXHQgICAgICBlbmRUaW1lLFxuXHQgICAgICBpLFxuXHQgICAgICBlbCxcblx0ICAgICAgY29tcCxcblx0ICAgICAgc3RhdGUsXG5cdCAgICAgIHRhcmdldHMsXG5cdCAgICAgIGZpbmFsU3RhdGVzLFxuXHQgICAgICBmcm9tTm9kZSxcblx0ICAgICAgdG9Ob2RlLFxuXHQgICAgICBydW4sXG5cdCAgICAgIGEsXG5cdCAgICAgIGI7XG5cblx0ICBmb3IgKHAgaW4gdG9TdGF0ZS5pZExvb2t1cCkge1xuXHQgICAgdG9Ob2RlID0gIXRvU3RhdGUuYWx0W3BdID8gdG9TdGF0ZS5pZExvb2t1cFtwXSA6IF9nZXRDaGFuZ2luZ0VsU3RhdGUodG9TdGF0ZSwgZnJvbVN0YXRlLCBwKTtcblx0ICAgIGVsID0gdG9Ob2RlLmVsZW1lbnQ7XG5cdCAgICBmcm9tTm9kZSA9IGZyb21TdGF0ZS5pZExvb2t1cFtwXTtcblx0ICAgIGZyb21TdGF0ZS5hbHRbcF0gJiYgZWwgPT09IGZyb21Ob2RlLmVsZW1lbnQgJiYgKGZyb21TdGF0ZS5hbHRbcF0uaXNWaXNpYmxlIHx8ICF0b05vZGUuaXNWaXNpYmxlKSAmJiAoZnJvbU5vZGUgPSBmcm9tU3RhdGUuYWx0W3BdKTtcblxuXHQgICAgaWYgKGZyb21Ob2RlKSB7XG5cdCAgICAgIGNvbXAgPSB7XG5cdCAgICAgICAgdDogZWwsXG5cdCAgICAgICAgYjogZnJvbU5vZGUsXG5cdCAgICAgICAgYTogdG9Ob2RlLFxuXHQgICAgICAgIHNkOiBmcm9tTm9kZS5lbGVtZW50ID09PSBlbCA/IDAgOiB0b05vZGUuaXNWaXNpYmxlID8gMSA6IC0xXG5cdCAgICAgIH07XG5cdCAgICAgIGNvbXBzLnB1c2goY29tcCk7XG5cblx0ICAgICAgaWYgKGNvbXAuc2QpIHtcblx0ICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcblx0ICAgICAgICAgIGNvbXAuYiA9IHRvTm9kZTtcblx0ICAgICAgICAgIGNvbXAuYSA9IGZyb21Ob2RlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGludGVycnVwdGVkICYmIF9yZWNvcmRJbmxpbmVTdHlsZXMoY29tcC5iLCBwcm9wcyA/IF9tZW1vaXplZFJlbW92ZVByb3BzW3Byb3BzXSA6IF9yZW1vdmVQcm9wcyk7XG5cdCAgICAgICAgZmFkZSAmJiBjb21wcy5wdXNoKGNvbXAuc3dhcCA9IHtcblx0ICAgICAgICAgIHQ6IGZyb21Ob2RlLmVsZW1lbnQsXG5cdCAgICAgICAgICBiOiBjb21wLmIsXG5cdCAgICAgICAgICBhOiBjb21wLmEsXG5cdCAgICAgICAgICBzZDogLWNvbXAuc2QsXG5cdCAgICAgICAgICBzd2FwOiBjb21wXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBlbC5fZmxpcCA9IGZyb21Ob2RlLmVsZW1lbnQuX2ZsaXAgPSBfYmF0Y2ggPyBfYmF0Y2gudGltZWxpbmUgOiBhbmltYXRpb247XG5cdCAgICB9IGVsc2UgaWYgKHRvTm9kZS5pc1Zpc2libGUpIHtcblx0ICAgICAgY29tcHMucHVzaCh7XG5cdCAgICAgICAgdDogZWwsXG5cdCAgICAgICAgYjogX2NvcHkodG9Ob2RlLCB7XG5cdCAgICAgICAgICBpc1Zpc2libGU6IDFcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBhOiB0b05vZGUsXG5cdCAgICAgICAgc2Q6IDAsXG5cdCAgICAgICAgZW50ZXJpbmc6IDFcblx0ICAgICAgfSk7XG5cdCAgICAgIGVsLl9mbGlwID0gX2JhdGNoID8gX2JhdGNoLnRpbWVsaW5lIDogYW5pbWF0aW9uO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHByb3BzICYmIChfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcblx0ICAgIHJldHVybiB0d2VlblZhcnNbcF0gPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICByZXR1cm4gY29tcHNbaV0uYS5wcm9wc1twXTtcblx0ICAgIH07XG5cdCAgfSk7XG5cdCAgY29tcHMuZmluYWxTdGF0ZXMgPSBmaW5hbFN0YXRlcyA9IFtdO1xuXG5cdCAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuXHQgICAgX29yZGVyQnlET01EZXB0aChjb21wcyk7XG5cblx0ICAgIF9sb2NrQm9keVNjcm9sbCh0cnVlKTtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGNvbXAgPSBjb21wc1tpXTtcblx0ICAgICAgYSA9IGNvbXAuYTtcblx0ICAgICAgYiA9IGNvbXAuYjtcblxuXHQgICAgICBpZiAocHJ1bmUgJiYgIWEuaXNEaWZmZXJlbnQoYikgJiYgIWNvbXAuZW50ZXJpbmcpIHtcblx0ICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlbCA9IGNvbXAudDtcblx0ICAgICAgICBuZXN0ZWQgJiYgIShjb21wLnNkIDwgMCkgJiYgaSAmJiAoYS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpO1xuXG5cdCAgICAgICAgaWYgKGIuaXNWaXNpYmxlICYmIGEuaXNWaXNpYmxlKSB7XG5cdCAgICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcblx0ICAgICAgICAgICAgc3RhdGUgPSBuZXcgRWxlbWVudFN0YXRlKGVsLCBwcm9wcywgZnJvbVN0YXRlLnNpbXBsZSk7XG5cblx0ICAgICAgICAgICAgX2ZpdChzdGF0ZSwgYSwgc2NhbGUsIDAsIDAsIHN0YXRlKTtcblxuXHQgICAgICAgICAgICBzdGF0ZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIHN0YXRlLmNzcyA9IGNvbXAuYi5jc3M7XG5cdCAgICAgICAgICAgIGNvbXAuYSA9IGEgPSBzdGF0ZTtcblx0ICAgICAgICAgICAgZmFkZSAmJiAoZWwuc3R5bGUub3BhY2l0eSA9IGludGVycnVwdGVkID8gYi5vcGFjaXR5IDogYS5vcGFjaXR5KTtcblx0ICAgICAgICAgICAgc3RhZ2dlciAmJiBzd2FwT3V0VGFyZ2V0cy5wdXNoKGVsKTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY29tcC5zZCA+IDAgJiYgZmFkZSkge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gaW50ZXJydXB0ZWQgPyBhLm9wYWNpdHkgLSBiLm9wYWNpdHkgOiBcIjBcIjtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgX2ZpdChhLCBiLCBzY2FsZSwgcHJvcHMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYi5pc1Zpc2libGUgIT09IGEuaXNWaXNpYmxlKSB7XG5cdCAgICAgICAgICBpZiAoIWIuaXNWaXNpYmxlKSB7XG5cdCAgICAgICAgICAgIGEuaXNWaXNpYmxlICYmIGVudGVyaW5nLnB1c2goYSk7XG5cdCAgICAgICAgICAgIGNvbXBzLnNwbGljZShpLS0sIDEpO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghYS5pc1Zpc2libGUpIHtcblx0ICAgICAgICAgICAgYi5jc3MgPSBhLmNzcztcblx0ICAgICAgICAgICAgbGVhdmluZy5wdXNoKGIpO1xuXHQgICAgICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcblx0ICAgICAgICAgICAgYWJzb2x1dGUgJiYgbmVzdGVkICYmIF9maXQoYSwgYiwgc2NhbGUsIHByb3BzKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXNjYWxlKSB7XG5cdCAgICAgICAgICBlbC5zdHlsZS5tYXhXaWR0aCA9IE1hdGgubWF4KGEud2lkdGgsIGIud2lkdGgpICsgXCJweFwiO1xuXHQgICAgICAgICAgZWwuc3R5bGUubWF4SGVpZ2h0ID0gTWF0aC5tYXgoYS5oZWlnaHQsIGIuaGVpZ2h0KSArIFwicHhcIjtcblx0ICAgICAgICAgIGVsLnN0eWxlLm1pbldpZHRoID0gTWF0aC5taW4oYS53aWR0aCwgYi53aWR0aCkgKyBcInB4XCI7XG5cdCAgICAgICAgICBlbC5zdHlsZS5taW5IZWlnaHQgPSBNYXRoLm1pbihhLmhlaWdodCwgYi5oZWlnaHQpICsgXCJweFwiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5lc3RlZCAmJiB0b2dnbGVDbGFzcyAmJiBlbC5jbGFzc0xpc3QuYWRkKHRvZ2dsZUNsYXNzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZpbmFsU3RhdGVzLnB1c2goYSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjbGFzc1RhcmdldHM7XG5cblx0ICAgIGlmICh0b2dnbGVDbGFzcykge1xuXHQgICAgICBjbGFzc1RhcmdldHMgPSBmaW5hbFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHtcblx0ICAgICAgICByZXR1cm4gcy5lbGVtZW50O1xuXHQgICAgICB9KTtcblx0ICAgICAgbmVzdGVkICYmIGNsYXNzVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZSh0b2dnbGVDbGFzcyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBfbG9ja0JvZHlTY3JvbGwoZmFsc2UpO1xuXG5cdCAgICBpZiAoc2NhbGUpIHtcblx0ICAgICAgdHdlZW5WYXJzLnNjYWxlWCA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBzW2ldLmEuc2NhbGVYO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIHR3ZWVuVmFycy5zY2FsZVkgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgIHJldHVybiBjb21wc1tpXS5hLnNjYWxlWTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHR3ZWVuVmFycy53aWR0aCA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBzW2ldLmEud2lkdGggKyBcInB4XCI7XG5cdCAgICAgIH07XG5cblx0ICAgICAgdHdlZW5WYXJzLmhlaWdodCA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBzW2ldLmEuaGVpZ2h0ICsgXCJweFwiO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIHR3ZWVuVmFycy5hdXRvUm91bmQgPSB2YXJzLmF1dG9Sb3VuZCB8fCBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgdHdlZW5WYXJzLnggPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICByZXR1cm4gY29tcHNbaV0uYS54ICsgXCJweFwiO1xuXHQgICAgfTtcblxuXHQgICAgdHdlZW5WYXJzLnkgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICByZXR1cm4gY29tcHNbaV0uYS55ICsgXCJweFwiO1xuXHQgICAgfTtcblxuXHQgICAgdHdlZW5WYXJzLnJvdGF0aW9uID0gZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgcmV0dXJuIGNvbXBzW2ldLmEucm90YXRpb24gKyAoc3BpbiA/IHNwaW5GdW5jKGksIHRhcmdldHNbaV0sIHRhcmdldHMpICogMzYwIDogMCk7XG5cdCAgICB9O1xuXG5cdCAgICB0d2VlblZhcnMuc2tld1ggPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICByZXR1cm4gY29tcHNbaV0uYS5za2V3WDtcblx0ICAgIH07XG5cblx0ICAgIHRhcmdldHMgPSBjb21wcy5tYXAoZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgcmV0dXJuIGMudDtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoX3pJbmRleCB8fCBfekluZGV4ID09PSAwKSB7XG5cdCAgICAgIHR3ZWVuVmFycy5tb2RpZmllcnMgPSB7XG5cdCAgICAgICAgekluZGV4OiBmdW5jdGlvbiB6SW5kZXgoKSB7XG5cdCAgICAgICAgICByZXR1cm4gX3pJbmRleDtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIHR3ZWVuVmFycy56SW5kZXggPSBfekluZGV4O1xuXHQgICAgICB0d2VlblZhcnMuaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBmYWRlICYmICh0d2VlblZhcnMub3BhY2l0eSA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgIHJldHVybiBjb21wc1tpXS5zZCA8IDAgPyAwIDogY29tcHNbaV0uc2QgPiAwID8gY29tcHNbaV0uYS5vcGFjaXR5IDogXCIrPTBcIjtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoc3dhcE91dFRhcmdldHMubGVuZ3RoKSB7XG5cdCAgICAgIHN0YWdnZXIgPSBnc2FwLnV0aWxzLmRpc3RyaWJ1dGUoc3RhZ2dlcik7XG5cdCAgICAgIHZhciBkdW1teUFycmF5ID0gdGFyZ2V0cy5zbGljZShzd2FwT3V0VGFyZ2V0cy5sZW5ndGgpO1xuXG5cdCAgICAgIHR3ZWVuVmFycy5zdGFnZ2VyID0gZnVuY3Rpb24gKGksIGVsKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0YWdnZXIofnN3YXBPdXRUYXJnZXRzLmluZGV4T2YoZWwpID8gdGFyZ2V0cy5pbmRleE9mKGNvbXBzW2ldLnN3YXAudCkgOiBpLCBlbCwgZHVtbXlBcnJheSk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIF9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICByZXR1cm4gdmFyc1tuYW1lXSAmJiBhbmltYXRpb24uZXZlbnRDYWxsYmFjayhuYW1lLCB2YXJzW25hbWVdLCB2YXJzW25hbWUgKyBcIlBhcmFtc1wiXSk7XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKGN1c3RvbSAmJiB0YXJnZXRzLmxlbmd0aCkge1xuXHQgICAgICByZW1haW5pbmdQcm9wcyA9IF9jb3B5KHR3ZWVuVmFycywgX3Jlc2VydmVkKTtcblxuXHQgICAgICBpZiAoXCJzY2FsZVwiIGluIGN1c3RvbSkge1xuXHQgICAgICAgIGN1c3RvbS5zY2FsZVggPSBjdXN0b20uc2NhbGVZID0gY3VzdG9tLnNjYWxlO1xuXHQgICAgICAgIGRlbGV0ZSBjdXN0b20uc2NhbGU7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHAgaW4gY3VzdG9tKSB7XG5cdCAgICAgICAgdiA9IF9jb3B5KGN1c3RvbVtwXSwgX2ZpdFJlc2VydmVkKTtcblx0ICAgICAgICB2W3BdID0gdHdlZW5WYXJzW3BdO1xuXHQgICAgICAgICEoXCJkdXJhdGlvblwiIGluIHYpICYmIFwiZHVyYXRpb25cIiBpbiB0d2VlblZhcnMgJiYgKHYuZHVyYXRpb24gPSB0d2VlblZhcnMuZHVyYXRpb24pO1xuXHQgICAgICAgIHYuc3RhZ2dlciA9IHR3ZWVuVmFycy5zdGFnZ2VyO1xuXHQgICAgICAgIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHYsIDApO1xuXHQgICAgICAgIGRlbGV0ZSByZW1haW5pbmdQcm9wc1twXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGFyZ2V0cy5sZW5ndGggfHwgbGVhdmluZy5sZW5ndGggfHwgZW50ZXJpbmcubGVuZ3RoKSB7XG5cdCAgICAgIHRvZ2dsZUNsYXNzICYmIGFuaW1hdGlvbi5hZGQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfdG9nZ2xlQ2xhc3MoY2xhc3NUYXJnZXRzLCB0b2dnbGVDbGFzcywgYW5pbWF0aW9uLl96VGltZSA8IDAgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG5cdCAgICAgIH0sIDApICYmICFwYXVzZWQgJiYgX3RvZ2dsZUNsYXNzKGNsYXNzVGFyZ2V0cywgdG9nZ2xlQ2xhc3MsIFwiYWRkXCIpO1xuXHQgICAgICB0YXJnZXRzLmxlbmd0aCAmJiBhZGRGdW5jLmNhbGwoYW5pbWF0aW9uLCB0YXJnZXRzLCByZW1haW5pbmdQcm9wcywgMCk7XG5cdCAgICB9XG5cblx0ICAgIF9oYW5kbGVDYWxsYmFjayhvbkVudGVyLCBlbnRlcmluZywgYW5pbWF0aW9uKTtcblxuXHQgICAgX2hhbmRsZUNhbGxiYWNrKG9uTGVhdmUsIGxlYXZpbmcsIGFuaW1hdGlvbik7XG5cblx0ICAgIHZhciBiYXRjaFRsID0gX2JhdGNoICYmIF9iYXRjaC50aW1lbGluZTtcblxuXHQgICAgaWYgKGJhdGNoVGwpIHtcblx0ICAgICAgYmF0Y2hUbC5hZGQoYW5pbWF0aW9uLCAwKTtcblxuXHQgICAgICBfYmF0Y2guX2ZpbmFsLnB1c2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfc2V0RmluYWxTdGF0ZXMoY29tcHMsICFjbGVhclByb3BzKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGVuZFRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24oKTtcblx0ICAgIGFuaW1hdGlvbi5jYWxsKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGZvcndhcmQgPSBhbmltYXRpb24udGltZSgpID49IGVuZFRpbWU7XG5cdCAgICAgIGZvcndhcmQgJiYgIWJhdGNoVGwgJiYgX3NldEZpbmFsU3RhdGVzKGNvbXBzLCAhY2xlYXJQcm9wcyk7XG5cdCAgICAgIHRvZ2dsZUNsYXNzICYmIF90b2dnbGVDbGFzcyhjbGFzc1RhcmdldHMsIHRvZ2dsZUNsYXNzLCBmb3J3YXJkID8gXCJyZW1vdmVcIiA6IFwiYWRkXCIpO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIGFic29sdXRlT25MZWF2ZSAmJiAoYWJzb2x1dGUgPSBjb21wcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXApIHtcblx0ICAgIHJldHVybiAhY29tcC5zZCAmJiAhY29tcC5hLmlzVmlzaWJsZSAmJiBjb21wLmIuaXNWaXNpYmxlO1xuXHQgIH0pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuXHQgICAgcmV0dXJuIGNvbXAuYS5lbGVtZW50O1xuXHQgIH0pKTtcblxuXHQgIGlmIChfYmF0Y2gpIHtcblx0ICAgIHZhciBfYmF0Y2gkX2FicztcblxuXHQgICAgYWJzb2x1dGUgJiYgKF9iYXRjaCRfYWJzID0gX2JhdGNoLl9hYnMpLnB1c2guYXBwbHkoX2JhdGNoJF9hYnMsIF9maWx0ZXJDb21wcyhjb21wcywgYWJzb2x1dGUpKTtcblxuXHQgICAgX2JhdGNoLl9ydW4ucHVzaChydW4pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBhYnNvbHV0ZSAmJiBfbWFrZUNvbXBzQWJzb2x1dGUoX2ZpbHRlckNvbXBzKGNvbXBzLCBhYnNvbHV0ZSkpO1xuXHQgICAgcnVuKCk7XG5cdCAgfVxuXG5cdCAgdmFyIGFuaW0gPSBfYmF0Y2ggPyBfYmF0Y2gudGltZWxpbmUgOiBhbmltYXRpb247XG5cblx0ICBhbmltLnJldmVydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBfa2lsbEZsaXAoYW5pbSwgMSk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBhbmltO1xuXHR9LFxuXHQgICAgX2ludGVycnVwdCA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHQodGwpIHtcblx0ICB0bC52YXJzLm9uSW50ZXJydXB0ICYmIHRsLnZhcnMub25JbnRlcnJ1cHQuYXBwbHkodGwsIHRsLnZhcnMub25JbnRlcnJ1cHRQYXJhbXMgfHwgW10pO1xuXHQgIHRsLmdldENoaWxkcmVuKHRydWUsIGZhbHNlLCB0cnVlKS5mb3JFYWNoKF9pbnRlcnJ1cHQpO1xuXHR9LFxuXHQgICAgX2tpbGxGbGlwID0gZnVuY3Rpb24gX2tpbGxGbGlwKHRsLCBhY3Rpb24pIHtcblx0ICBpZiAodGwgJiYgdGwucHJvZ3Jlc3MoKSA8IDEgJiYgIXRsLnBhdXNlZCgpKSB7XG5cdCAgICBpZiAoYWN0aW9uKSB7XG5cdCAgICAgIF9pbnRlcnJ1cHQodGwpO1xuXG5cdCAgICAgIGFjdGlvbiA8IDIgJiYgdGwucHJvZ3Jlc3MoMSk7XG5cdCAgICAgIHRsLmtpbGwoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9LFxuXHQgICAgX2NyZWF0ZUxvb2t1cCA9IGZ1bmN0aW9uIF9jcmVhdGVMb29rdXAoc3RhdGUpIHtcblx0ICB2YXIgbG9va3VwID0gc3RhdGUuaWRMb29rdXAgPSB7fSxcblx0ICAgICAgYWx0ID0gc3RhdGUuYWx0ID0ge30sXG5cdCAgICAgIGVsU3RhdGVzID0gc3RhdGUuZWxlbWVudFN0YXRlcyxcblx0ICAgICAgaSA9IGVsU3RhdGVzLmxlbmd0aCxcblx0ICAgICAgZWxTdGF0ZTtcblxuXHQgIHdoaWxlIChpLS0pIHtcblx0ICAgIGVsU3RhdGUgPSBlbFN0YXRlc1tpXTtcblx0ICAgIGxvb2t1cFtlbFN0YXRlLmlkXSA/IGFsdFtlbFN0YXRlLmlkXSA9IGVsU3RhdGUgOiBsb29rdXBbZWxTdGF0ZS5pZF0gPSBlbFN0YXRlO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgRmxpcFN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEZsaXBTdGF0ZSh0YXJnZXRzLCB2YXJzLCB0YXJnZXRzQXJlRWxlbWVudFN0YXRlcykge1xuXHQgICAgdGhpcy5wcm9wcyA9IHZhcnMgJiYgdmFycy5wcm9wcztcblx0ICAgIHRoaXMuc2ltcGxlID0gISEodmFycyAmJiB2YXJzLnNpbXBsZSk7XG5cblx0ICAgIGlmICh0YXJnZXRzQXJlRWxlbWVudFN0YXRlcykge1xuXHQgICAgICB0aGlzLnRhcmdldHMgPSBfZWxlbWVudHNGcm9tRWxlbWVudFN0YXRlcyh0YXJnZXRzKTtcblx0ICAgICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGFyZ2V0cztcblxuXHQgICAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy50YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG5cdCAgICAgIHZhciBzb2Z0ID0gdmFycyAmJiAodmFycy5raWxsID09PSBmYWxzZSB8fCB2YXJzLmJhdGNoICYmICF2YXJzLmtpbGwpO1xuXHQgICAgICBfYmF0Y2ggJiYgIXNvZnQgJiYgX2JhdGNoLl9raWxsLnB1c2godGhpcyk7XG5cdCAgICAgIHRoaXMudXBkYXRlKHNvZnQgfHwgISFfYmF0Y2gpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBfcHJvdG8gPSBGbGlwU3RhdGUucHJvdG90eXBlO1xuXG5cdCAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzb2Z0KSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICB0aGlzLmVsZW1lbnRTdGF0ZXMgPSB0aGlzLnRhcmdldHMubWFwKGZ1bmN0aW9uIChlbCkge1xuXHQgICAgICByZXR1cm4gbmV3IEVsZW1lbnRTdGF0ZShlbCwgX3RoaXMucHJvcHMsIF90aGlzLnNpbXBsZSk7XG5cdCAgICB9KTtcblxuXHQgICAgX2NyZWF0ZUxvb2t1cCh0aGlzKTtcblxuXHQgICAgdGhpcy5pbnRlcnJ1cHQoc29mdCk7XG5cdCAgICB0aGlzLnJlY29yZElubGluZVN0eWxlcygpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHQgICAgdGhpcy50YXJnZXRzLmxlbmd0aCA9IHRoaXMuZWxlbWVudFN0YXRlcy5sZW5ndGggPSAwO1xuXG5cdCAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmZpdCA9IGZ1bmN0aW9uIGZpdChzdGF0ZSwgc2NhbGUsIG5lc3RlZCkge1xuXHQgICAgdmFyIGVsU3RhdGVzSW5PcmRlciA9IF9vcmRlckJ5RE9NRGVwdGgodGhpcy5lbGVtZW50U3RhdGVzLnNsaWNlKDApLCBmYWxzZSwgdHJ1ZSksXG5cdCAgICAgICAgdG9FbFN0YXRlcyA9IChzdGF0ZSB8fCB0aGlzKS5pZExvb2t1cCxcblx0ICAgICAgICBpID0gMCxcblx0ICAgICAgICBmcm9tTm9kZSxcblx0ICAgICAgICB0b05vZGU7XG5cblx0ICAgIGZvciAoOyBpIDwgZWxTdGF0ZXNJbk9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGZyb21Ob2RlID0gZWxTdGF0ZXNJbk9yZGVyW2ldO1xuXHQgICAgICBuZXN0ZWQgJiYgKGZyb21Ob2RlLm1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChmcm9tTm9kZS5lbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpKTtcblx0ICAgICAgdG9Ob2RlID0gdG9FbFN0YXRlc1tmcm9tTm9kZS5pZF07XG5cdCAgICAgIHRvTm9kZSAmJiBfZml0KGZyb21Ob2RlLCB0b05vZGUsIHNjYWxlLCB0cnVlLCAwLCBmcm9tTm9kZSk7XG5cdCAgICAgIGZyb21Ob2RlLm1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChmcm9tTm9kZS5lbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0ICAgIHZhciBlcyA9IHRoaXMuZ2V0RWxlbWVudFN0YXRlKGVsZW1lbnQpIHx8IF9lbXB0eU9iajtcblxuXHQgICAgcmV0dXJuIChwcm9wZXJ0eSBpbiBlcyA/IGVzIDogZXMucHJvcHMgfHwgX2VtcHR5T2JqKVtwcm9wZXJ0eV07XG5cdCAgfTtcblxuXHQgIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3RhdGUpIHtcblx0ICAgIHZhciBpID0gc3RhdGUudGFyZ2V0cy5sZW5ndGgsXG5cdCAgICAgICAgbG9va3VwID0gdGhpcy5pZExvb2t1cCxcblx0ICAgICAgICBhbHQgPSB0aGlzLmFsdCxcblx0ICAgICAgICBpbmRleCxcblx0ICAgICAgICBlcyxcblx0ICAgICAgICBlczI7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgZXMgPSBzdGF0ZS5lbGVtZW50U3RhdGVzW2ldO1xuXHQgICAgICBlczIgPSBsb29rdXBbZXMuaWRdO1xuXG5cdCAgICAgIGlmIChlczIgJiYgKGVzLmVsZW1lbnQgPT09IGVzMi5lbGVtZW50IHx8IGFsdFtlcy5pZF0gJiYgYWx0W2VzLmlkXS5lbGVtZW50ID09PSBlcy5lbGVtZW50KSkge1xuXHQgICAgICAgIGluZGV4ID0gdGhpcy5lbGVtZW50U3RhdGVzLmluZGV4T2YoZXMuZWxlbWVudCA9PT0gZXMyLmVsZW1lbnQgPyBlczIgOiBhbHRbZXMuaWRdKTtcblx0ICAgICAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxLCBzdGF0ZS50YXJnZXRzW2ldKTtcblx0ICAgICAgICB0aGlzLmVsZW1lbnRTdGF0ZXMuc3BsaWNlKGluZGV4LCAxLCBlcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy50YXJnZXRzLnB1c2goc3RhdGUudGFyZ2V0c1tpXSk7XG5cdCAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVzLnB1c2goZXMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmludGVycnVwdGVkICYmICh0aGlzLmludGVycnVwdGVkID0gdHJ1ZSk7XG5cdCAgICBzdGF0ZS5zaW1wbGUgfHwgKHRoaXMuc2ltcGxlID0gZmFsc2UpO1xuXG5cdCAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHN0YXRlKSB7XG5cdCAgICB2YXIgbDEgPSBzdGF0ZS5pZExvb2t1cCxcblx0ICAgICAgICBsMiA9IHRoaXMuaWRMb29rdXAsXG5cdCAgICAgICAgdW5jaGFuZ2VkID0gW10sXG5cdCAgICAgICAgY2hhbmdlZCA9IFtdLFxuXHQgICAgICAgIGVudGVyID0gW10sXG5cdCAgICAgICAgbGVhdmUgPSBbXSxcblx0ICAgICAgICB0YXJnZXRzID0gW10sXG5cdCAgICAgICAgYTEgPSBzdGF0ZS5hbHQsXG5cdCAgICAgICAgYTIgPSB0aGlzLmFsdCxcblx0ICAgICAgICBwbGFjZSA9IGZ1bmN0aW9uIHBsYWNlKHMxLCBzMiwgZWwpIHtcblx0ICAgICAgcmV0dXJuIChzMS5pc1Zpc2libGUgIT09IHMyLmlzVmlzaWJsZSA/IHMxLmlzVmlzaWJsZSA/IGVudGVyIDogbGVhdmUgOiBzMS5pc1Zpc2libGUgPyBjaGFuZ2VkIDogdW5jaGFuZ2VkKS5wdXNoKGVsKSAmJiB0YXJnZXRzLnB1c2goZWwpO1xuXHQgICAgfSxcblx0ICAgICAgICBwbGFjZUlmRG9lc05vdEV4aXN0ID0gZnVuY3Rpb24gcGxhY2VJZkRvZXNOb3RFeGlzdChzMSwgczIsIGVsKSB7XG5cdCAgICAgIHJldHVybiB0YXJnZXRzLmluZGV4T2YoZWwpIDwgMCAmJiBwbGFjZShzMSwgczIsIGVsKTtcblx0ICAgIH0sXG5cdCAgICAgICAgczEsXG5cdCAgICAgICAgczIsXG5cdCAgICAgICAgcCxcblx0ICAgICAgICBlbCxcblx0ICAgICAgICBzMUFsdCxcblx0ICAgICAgICBzMkFsdCxcblx0ICAgICAgICBjMSxcblx0ICAgICAgICBjMjtcblxuXHQgICAgZm9yIChwIGluIGwxKSB7XG5cdCAgICAgIHMxQWx0ID0gYTFbcF07XG5cdCAgICAgIHMyQWx0ID0gYTJbcF07XG5cdCAgICAgIHMxID0gIXMxQWx0ID8gbDFbcF0gOiBfZ2V0Q2hhbmdpbmdFbFN0YXRlKHN0YXRlLCB0aGlzLCBwKTtcblx0ICAgICAgZWwgPSBzMS5lbGVtZW50O1xuXHQgICAgICBzMiA9IGwyW3BdO1xuXG5cdCAgICAgIGlmIChzMkFsdCkge1xuXHQgICAgICAgIGMyID0gczIuaXNWaXNpYmxlIHx8ICFzMkFsdC5pc1Zpc2libGUgJiYgZWwgPT09IHMyLmVsZW1lbnQgPyBzMiA6IHMyQWx0O1xuXHQgICAgICAgIGMxID0gczFBbHQgJiYgIXMxLmlzVmlzaWJsZSAmJiAhczFBbHQuaXNWaXNpYmxlICYmIGMyLmVsZW1lbnQgPT09IHMxQWx0LmVsZW1lbnQgPyBzMUFsdCA6IHMxO1xuXG5cdCAgICAgICAgaWYgKGMxLmlzVmlzaWJsZSAmJiBjMi5pc1Zpc2libGUgJiYgYzEuZWxlbWVudCAhPT0gYzIuZWxlbWVudCkge1xuXHQgICAgICAgICAgKGMxLmlzRGlmZmVyZW50KGMyKSA/IGNoYW5nZWQgOiB1bmNoYW5nZWQpLnB1c2goYzEuZWxlbWVudCwgYzIuZWxlbWVudCk7XG5cdCAgICAgICAgICB0YXJnZXRzLnB1c2goYzEuZWxlbWVudCwgYzIuZWxlbWVudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHBsYWNlKGMxLCBjMiwgYzEuZWxlbWVudCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgczFBbHQgJiYgYzEuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCAmJiAoczFBbHQgPSBsMVtwXSk7XG5cdCAgICAgICAgcGxhY2VJZkRvZXNOb3RFeGlzdChjMS5lbGVtZW50ICE9PSBzMi5lbGVtZW50ICYmIHMxQWx0ID8gczFBbHQgOiBjMSwgczIsIHMyLmVsZW1lbnQpO1xuXHQgICAgICAgIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQgJiYgczFBbHQuZWxlbWVudCA9PT0gczJBbHQuZWxlbWVudCA/IHMxQWx0IDogYzEsIHMyQWx0LCBzMkFsdC5lbGVtZW50KTtcblx0ICAgICAgICBzMUFsdCAmJiBwbGFjZUlmRG9lc05vdEV4aXN0KHMxQWx0LCBzMkFsdC5lbGVtZW50ID09PSBzMUFsdC5lbGVtZW50ID8gczJBbHQgOiBzMiwgczFBbHQuZWxlbWVudCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgIXMyID8gZW50ZXIucHVzaChlbCkgOiAhczIuaXNEaWZmZXJlbnQoczEpID8gdW5jaGFuZ2VkLnB1c2goZWwpIDogcGxhY2UoczEsIHMyLCBlbCk7XG5cdCAgICAgICAgczFBbHQgJiYgcGxhY2VJZkRvZXNOb3RFeGlzdChzMUFsdCwgczIsIHMxQWx0LmVsZW1lbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZvciAocCBpbiBsMikge1xuXHQgICAgICBpZiAoIWwxW3BdKSB7XG5cdCAgICAgICAgbGVhdmUucHVzaChsMltwXS5lbGVtZW50KTtcblx0ICAgICAgICBhMltwXSAmJiBsZWF2ZS5wdXNoKGEyW3BdLmVsZW1lbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGNoYW5nZWQ6IGNoYW5nZWQsXG5cdCAgICAgIHVuY2hhbmdlZDogdW5jaGFuZ2VkLFxuXHQgICAgICBlbnRlcjogZW50ZXIsXG5cdCAgICAgIGxlYXZlOiBsZWF2ZVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnJlY29yZElubGluZVN0eWxlcyA9IGZ1bmN0aW9uIHJlY29yZElubGluZVN0eWxlcygpIHtcblx0ICAgIHZhciBwcm9wcyA9IF9tZW1vaXplZFJlbW92ZVByb3BzW3RoaXMucHJvcHNdIHx8IF9yZW1vdmVQcm9wcyxcblx0ICAgICAgICBpID0gdGhpcy5lbGVtZW50U3RhdGVzLmxlbmd0aDtcblxuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICBfcmVjb3JkSW5saW5lU3R5bGVzKHRoaXMuZWxlbWVudFN0YXRlc1tpXSwgcHJvcHMpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBfcHJvdG8uaW50ZXJydXB0ID0gZnVuY3Rpb24gaW50ZXJydXB0KHNvZnQpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICB2YXIgdGltZWxpbmVzID0gW107XG5cdCAgICB0aGlzLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuXHQgICAgICB2YXIgdGwgPSB0Ll9mbGlwLFxuXHQgICAgICAgICAgZm91bmRJblByb2dyZXNzID0gX2tpbGxGbGlwKHRsLCBzb2Z0ID8gMCA6IDEpO1xuXG5cdCAgICAgIHNvZnQgJiYgZm91bmRJblByb2dyZXNzICYmIHRpbWVsaW5lcy5pbmRleE9mKHRsKSA8IDAgJiYgdGwuYWRkKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMyLnVwZGF0ZVZpc2liaWxpdHkoKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGZvdW5kSW5Qcm9ncmVzcyAmJiB0aW1lbGluZXMucHVzaCh0bCk7XG5cdCAgICB9KTtcblx0ICAgICFzb2Z0ICYmIHRpbWVsaW5lcy5sZW5ndGggJiYgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG5cdCAgICB0aGlzLmludGVycnVwdGVkIHx8ICh0aGlzLmludGVycnVwdGVkID0gISF0aW1lbGluZXMubGVuZ3RoKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KCkge1xuXHQgICAgdGhpcy5lbGVtZW50U3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKGVzKSB7XG5cdCAgICAgIHZhciBiID0gZXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgICAgZXMuaXNWaXNpYmxlID0gISEoYi53aWR0aCB8fCBiLmhlaWdodCB8fCBiLnRvcCB8fCBiLmxlZnQpO1xuXHQgICAgICBlcy51bmNhY2hlID0gMTtcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZ2V0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gZ2V0RWxlbWVudFN0YXRlKGVsZW1lbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGF0ZXNbdGhpcy50YXJnZXRzLmluZGV4T2YoX2dldEVsKGVsZW1lbnQpKV07XG5cdCAgfTtcblxuXHQgIF9wcm90by5tYWtlQWJzb2x1dGUgPSBmdW5jdGlvbiBtYWtlQWJzb2x1dGUoKSB7XG5cdCAgICByZXR1cm4gX29yZGVyQnlET01EZXB0aCh0aGlzLmVsZW1lbnRTdGF0ZXMuc2xpY2UoMCksIHRydWUsIHRydWUpLm1hcChfbWFrZUFic29sdXRlKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEZsaXBTdGF0ZTtcblx0fSgpO1xuXG5cdHZhciBFbGVtZW50U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gRWxlbWVudFN0YXRlKGVsZW1lbnQsIHByb3BzLCBzaW1wbGUpIHtcblx0ICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdCAgICB0aGlzLnVwZGF0ZShwcm9wcywgc2ltcGxlKTtcblx0ICB9XG5cblx0ICB2YXIgX3Byb3RvMiA9IEVsZW1lbnRTdGF0ZS5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8yLmlzRGlmZmVyZW50ID0gZnVuY3Rpb24gaXNEaWZmZXJlbnQoc3RhdGUpIHtcblx0ICAgIHZhciBiMSA9IHRoaXMuYm91bmRzLFxuXHQgICAgICAgIGIyID0gc3RhdGUuYm91bmRzO1xuXHQgICAgcmV0dXJuIGIxLnRvcCAhPT0gYjIudG9wIHx8IGIxLmxlZnQgIT09IGIyLmxlZnQgfHwgYjEud2lkdGggIT09IGIyLndpZHRoIHx8IGIxLmhlaWdodCAhPT0gYjIuaGVpZ2h0IHx8ICF0aGlzLm1hdHJpeC5lcXVhbHMoc3RhdGUubWF0cml4KSB8fCB0aGlzLm9wYWNpdHkgIT09IHN0YXRlLm9wYWNpdHkgfHwgdGhpcy5wcm9wcyAmJiBzdGF0ZS5wcm9wcyAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnByb3BzKSAhPT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUucHJvcHMpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8yLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgc2ltcGxlKSB7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXMsXG5cdCAgICAgICAgZWxlbWVudCA9IHNlbGYuZWxlbWVudCxcblx0ICAgICAgICBnZXRQcm9wID0gZ3NhcC5nZXRQcm9wZXJ0eShlbGVtZW50KSxcblx0ICAgICAgICBjYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KSxcblx0ICAgICAgICBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHQgICAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3ggJiYgdHlwZW9mIGVsZW1lbnQuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBlbGVtZW50LmdldEJCb3goKSxcblx0ICAgICAgICBtID0gc2ltcGxlID8gbmV3IE1hdHJpeDJEKDEsIDAsIDAsIDEsIGJvdW5kcy5sZWZ0ICsgX2dldERvY1Njcm9sbExlZnQoKSwgYm91bmRzLnRvcCArIF9nZXREb2NTY3JvbGxUb3AoKSkgOiBnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcblx0ICAgIHNlbGYuZ2V0UHJvcCA9IGdldFByb3A7XG5cdCAgICBzZWxmLmVsZW1lbnQgPSBlbGVtZW50O1xuXHQgICAgc2VsZi5pZCA9IF9nZXRJRChlbGVtZW50KTtcblx0ICAgIHNlbGYubWF0cml4ID0gbTtcblx0ICAgIHNlbGYuY2FjaGUgPSBjYWNoZTtcblx0ICAgIHNlbGYuYm91bmRzID0gYm91bmRzO1xuXHQgICAgc2VsZi5pc1Zpc2libGUgPSAhIShib3VuZHMud2lkdGggfHwgYm91bmRzLmhlaWdodCB8fCBib3VuZHMubGVmdCB8fCBib3VuZHMudG9wKTtcblx0ICAgIHNlbGYuZGlzcGxheSA9IGdldFByb3AoXCJkaXNwbGF5XCIpO1xuXHQgICAgc2VsZi5wb3NpdGlvbiA9IGdldFByb3AoXCJwb3NpdGlvblwiKTtcblx0ICAgIHNlbGYucGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHQgICAgc2VsZi54ID0gZ2V0UHJvcChcInhcIik7XG5cdCAgICBzZWxmLnkgPSBnZXRQcm9wKFwieVwiKTtcblx0ICAgIHNlbGYuc2NhbGVYID0gY2FjaGUuc2NhbGVYO1xuXHQgICAgc2VsZi5zY2FsZVkgPSBjYWNoZS5zY2FsZVk7XG5cdCAgICBzZWxmLnJvdGF0aW9uID0gZ2V0UHJvcChcInJvdGF0aW9uXCIpO1xuXHQgICAgc2VsZi5za2V3WCA9IGdldFByb3AoXCJza2V3WFwiKTtcblx0ICAgIHNlbGYub3BhY2l0eSA9IGdldFByb3AoXCJvcGFjaXR5XCIpO1xuXHQgICAgc2VsZi53aWR0aCA9IGJib3ggPyBiYm94LndpZHRoIDogX2Nsb3Nlc3RUZW50aChnZXRQcm9wKFwid2lkdGhcIiwgXCJweFwiKSwgMC4wNCk7XG5cdCAgICBzZWxmLmhlaWdodCA9IGJib3ggPyBiYm94LmhlaWdodCA6IF9jbG9zZXN0VGVudGgoZ2V0UHJvcChcImhlaWdodFwiLCBcInB4XCIpLCAwLjA0KTtcblx0ICAgIHByb3BzICYmIF9yZWNvcmRQcm9wcyhzZWxmLCBfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpO1xuXHQgICAgc2VsZi5jdG0gPSBlbGVtZW50LmdldENUTSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIgJiYgX2dldENUTShlbGVtZW50KS5pbnZlcnNlKCk7XG5cdCAgICBzZWxmLnNpbXBsZSA9IHNpbXBsZSB8fCBfcm91bmQobS5hKSA9PT0gMSAmJiAhX3JvdW5kKG0uYikgJiYgIV9yb3VuZChtLmMpICYmIF9yb3VuZChtLmQpID09PSAxO1xuXHQgICAgc2VsZi51bmNhY2hlID0gMDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVsZW1lbnRTdGF0ZTtcblx0fSgpO1xuXG5cdHZhciBGbGlwQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEZsaXBBY3Rpb24odmFycywgYmF0Y2gpIHtcblx0ICAgIHRoaXMudmFycyA9IHZhcnM7XG5cdCAgICB0aGlzLmJhdGNoID0gYmF0Y2g7XG5cdCAgICB0aGlzLnN0YXRlcyA9IFtdO1xuXHQgICAgdGhpcy50aW1lbGluZSA9IGJhdGNoLnRpbWVsaW5lO1xuXHQgIH1cblxuXHQgIHZhciBfcHJvdG8zID0gRmxpcEFjdGlvbi5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8zLmdldFN0YXRlQnlJZCA9IGZ1bmN0aW9uIGdldFN0YXRlQnlJZChpZCkge1xuXHQgICAgdmFyIGkgPSB0aGlzLnN0YXRlcy5sZW5ndGg7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgaWYgKHRoaXMuc3RhdGVzW2ldLmlkTG9va3VwW2lkXSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuXHQgICAgdGhpcy5iYXRjaC5yZW1vdmUodGhpcyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBGbGlwQWN0aW9uO1xuXHR9KCk7XG5cblx0dmFyIEZsaXBCYXRjaCA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBGbGlwQmF0Y2goaWQpIHtcblx0ICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuXHQgICAgdGhpcy5fa2lsbCA9IFtdO1xuXHQgICAgdGhpcy5fZmluYWwgPSBbXTtcblx0ICAgIHRoaXMuX2FicyA9IFtdO1xuXHQgICAgdGhpcy5fcnVuID0gW107XG5cdCAgICB0aGlzLmRhdGEgPSB7fTtcblx0ICAgIHRoaXMuc3RhdGUgPSBuZXcgRmxpcFN0YXRlKCk7XG5cdCAgICB0aGlzLnRpbWVsaW5lID0gZ3NhcC50aW1lbGluZSgpO1xuXHQgIH1cblxuXHQgIHZhciBfcHJvdG80ID0gRmxpcEJhdGNoLnByb3RvdHlwZTtcblxuXHQgIF9wcm90bzQuYWRkID0gZnVuY3Rpb24gYWRkKGNvbmZpZykge1xuXHQgICAgdmFyIHJlc3VsdCA9IHRoaXMuYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFjdGlvbikge1xuXHQgICAgICByZXR1cm4gYWN0aW9uLnZhcnMgPT09IGNvbmZpZztcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuXHQgICAgfVxuXG5cdCAgICByZXN1bHQgPSBuZXcgRmxpcEFjdGlvbih0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyB7XG5cdCAgICAgIGFuaW1hdGU6IGNvbmZpZ1xuXHQgICAgfSA6IGNvbmZpZywgdGhpcyk7XG5cdCAgICB0aGlzLmFjdGlvbnMucHVzaChyZXN1bHQpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgX3Byb3RvNC5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoYWN0aW9uKSB7XG5cdCAgICB2YXIgaSA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XG5cdCAgICBpID49IDAgJiYgdGhpcy5hY3Rpb25zLnNwbGljZShpLCAxKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBfcHJvdG80LmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUobWVyZ2UpIHtcblx0ICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdCAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuXHQgICAgICAgIHByZXZBY3Rpb24gPSBfYmF0Y2hBY3Rpb247XG5cdCAgICBfYmF0Y2ggPSB0aGlzO1xuXHQgICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuXHQgICAgdGhpcy5fa2lsbC5sZW5ndGggPSAwO1xuXHQgICAgdGhpcy5hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuXHQgICAgICBpZiAoYWN0aW9uLnZhcnMuZ2V0U3RhdGUpIHtcblx0ICAgICAgICBhY3Rpb24uc3RhdGVzLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgX2JhdGNoQWN0aW9uID0gYWN0aW9uO1xuXHQgICAgICAgIGFjdGlvbi5zdGF0ZSA9IGFjdGlvbi52YXJzLmdldFN0YXRlKGFjdGlvbik7XG5cdCAgICAgIH1cblxuXHQgICAgICBtZXJnZSAmJiBhY3Rpb24uc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMzLnN0YXRlLmFkZChzKTtcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICAgIF9iYXRjaEFjdGlvbiA9IHByZXZBY3Rpb247XG5cdCAgICBfYmF0Y2ggPSBwcmV2QmF0Y2g7XG5cdCAgICB0aGlzLmtpbGxDb25mbGljdHMoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBfcHJvdG80LmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKCkge1xuXHQgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cblx0ICAgIHZhciBwcmV2QmF0Y2ggPSBfYmF0Y2gsXG5cdCAgICAgICAgdGwgPSB0aGlzLnRpbWVsaW5lLFxuXHQgICAgICAgIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuXHQgICAgICAgIGZpbmFsU3RhdGVzLFxuXHQgICAgICAgIGVuZFRpbWU7XG5cdCAgICBfYmF0Y2ggPSB0aGlzO1xuXHQgICAgdGwuY2xlYXIoKTtcblx0ICAgIHRoaXMuX2Ficy5sZW5ndGggPSB0aGlzLl9maW5hbC5sZW5ndGggPSB0aGlzLl9ydW4ubGVuZ3RoID0gMDtcblx0ICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgIGEudmFycy5hbmltYXRlICYmIGEudmFycy5hbmltYXRlKGEpO1xuXHQgICAgICB2YXIgb25FbnRlciA9IGEudmFycy5vbkVudGVyLFxuXHQgICAgICAgICAgb25MZWF2ZSA9IGEudmFycy5vbkxlYXZlLFxuXHQgICAgICAgICAgdGFyZ2V0cyA9IGEudGFyZ2V0cyxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICByZXN1bHQ7XG5cblx0ICAgICAgaWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGggJiYgKG9uRW50ZXIgfHwgb25MZWF2ZSkpIHtcblx0ICAgICAgICBzID0gbmV3IEZsaXBTdGF0ZSgpO1xuXHQgICAgICAgIGEuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG5cdCAgICAgICAgICByZXR1cm4gcy5hZGQoc3RhdGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJlc3VsdCA9IHMuY29tcGFyZShGbGlwLmdldFN0YXRlKHRhcmdldHMpKTtcblx0ICAgICAgICByZXN1bHQuZW50ZXIubGVuZ3RoICYmIG9uRW50ZXIgJiYgb25FbnRlcihyZXN1bHQuZW50ZXIpO1xuXHQgICAgICAgIHJlc3VsdC5sZWF2ZS5sZW5ndGggJiYgb25MZWF2ZSAmJiBvbkxlYXZlKHJlc3VsdC5sZWF2ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBfbWFrZUNvbXBzQWJzb2x1dGUodGhpcy5fYWJzKTtcblxuXHQgICAgdGhpcy5fcnVuLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcblx0ICAgICAgcmV0dXJuIGYoKTtcblx0ICAgIH0pO1xuXG5cdCAgICBlbmRUaW1lID0gdGwuZHVyYXRpb24oKTtcblx0ICAgIGZpbmFsU3RhdGVzID0gdGhpcy5fZmluYWwuc2xpY2UoMCk7XG5cdCAgICB0bC5hZGQoZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoZW5kVGltZSA8PSB0bC50aW1lKCkpIHtcblx0ICAgICAgICBmaW5hbFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG5cdCAgICAgICAgICByZXR1cm4gZigpO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgX2ZvckVhY2hCYXRjaChfdGhpczQsIFwib25Db21wbGV0ZVwiKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBfYmF0Y2ggPSBwcmV2QmF0Y2g7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgdGhpcy5hY3Rpb25zW2ldLnZhcnMub25jZSAmJiB0aGlzLmFjdGlvbnNbaV0ua2lsbCgpO1xuXHQgICAgfVxuXG5cdCAgICBfZm9yRWFjaEJhdGNoKHRoaXMsIFwib25TdGFydFwiKTtcblxuXHQgICAgdGwucmVzdGFydCgpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIF9wcm90bzQubG9hZFN0YXRlID0gZnVuY3Rpb24gbG9hZFN0YXRlKGRvbmUpIHtcblx0ICAgIGRvbmUgfHwgKGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH0pO1xuXHQgICAgdmFyIHF1ZXVlID0gW107XG5cdCAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICBpZiAoYy52YXJzLmxvYWRTdGF0ZSkge1xuXHQgICAgICAgIHZhciBpLFxuXHQgICAgICAgICAgICBmID0gZnVuY3Rpb24gZih0YXJnZXRzKSB7XG5cdCAgICAgICAgICB0YXJnZXRzICYmIChjLnRhcmdldHMgPSB0YXJnZXRzKTtcblx0ICAgICAgICAgIGkgPSBxdWV1ZS5pbmRleE9mKGYpO1xuXG5cdCAgICAgICAgICBpZiAofmkpIHtcblx0ICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICBxdWV1ZS5sZW5ndGggfHwgZG9uZSgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBxdWV1ZS5wdXNoKGYpO1xuXHQgICAgICAgIGMudmFycy5sb2FkU3RhdGUoZik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcXVldWUubGVuZ3RoIHx8IGRvbmUoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBfcHJvdG80LnNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUoKSB7XG5cdCAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICByZXR1cm4gYy50YXJnZXRzID0gYy52YXJzLnNldFN0YXRlICYmIGMudmFycy5zZXRTdGF0ZShjKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIF9wcm90bzQua2lsbENvbmZsaWN0cyA9IGZ1bmN0aW9uIGtpbGxDb25mbGljdHMoc29mdCkge1xuXHQgICAgdGhpcy5zdGF0ZS5pbnRlcnJ1cHQoc29mdCk7XG5cblx0ICAgIHRoaXMuX2tpbGwuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcblx0ICAgICAgcmV0dXJuIHN0YXRlLmludGVycnVwdChzb2Z0KTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvNC5ydW4gPSBmdW5jdGlvbiBydW4oc2tpcEdldFN0YXRlLCBtZXJnZSkge1xuXHQgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cblx0ICAgIGlmICh0aGlzICE9PSBfYmF0Y2gpIHtcblx0ICAgICAgc2tpcEdldFN0YXRlIHx8IHRoaXMuZ2V0U3RhdGUobWVyZ2UpO1xuXHQgICAgICB0aGlzLmxvYWRTdGF0ZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCFfdGhpczUuX2tpbGxlZCkge1xuXHQgICAgICAgICAgX3RoaXM1LnNldFN0YXRlKCk7XG5cblx0ICAgICAgICAgIF90aGlzNS5hbmltYXRlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIF9wcm90bzQuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihzdGF0ZU9ubHkpIHtcblx0ICAgIHRoaXMuc3RhdGUuY2xlYXIoKTtcblx0ICAgIHN0YXRlT25seSB8fCAodGhpcy5hY3Rpb25zLmxlbmd0aCA9IDApO1xuXHQgIH07XG5cblx0ICBfcHJvdG80LmdldFN0YXRlQnlJZCA9IGZ1bmN0aW9uIGdldFN0YXRlQnlJZChpZCkge1xuXHQgICAgdmFyIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuXHQgICAgICAgIHM7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgcyA9IHRoaXMuYWN0aW9uc1tpXS5nZXRTdGF0ZUJ5SWQoaWQpO1xuXG5cdCAgICAgIGlmIChzKSB7XG5cdCAgICAgICAgcmV0dXJuIHM7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RhdGUuaWRMb29rdXBbaWRdICYmIHRoaXMuc3RhdGU7XG5cdCAgfTtcblxuXHQgIF9wcm90bzQua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG5cdCAgICB0aGlzLl9raWxsZWQgPSAxO1xuXHQgICAgdGhpcy5jbGVhcigpO1xuXHQgICAgZGVsZXRlIF9iYXRjaExvb2t1cFt0aGlzLmlkXTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEZsaXBCYXRjaDtcblx0fSgpO1xuXG5cdHZhciBGbGlwID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEZsaXAoKSB7fVxuXG5cdCAgRmxpcC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKHRhcmdldHMsIHZhcnMpIHtcblx0ICAgIHZhciBzdGF0ZSA9IF9wYXJzZVN0YXRlKHRhcmdldHMsIHZhcnMpO1xuXG5cdCAgICBfYmF0Y2hBY3Rpb24gJiYgX2JhdGNoQWN0aW9uLnN0YXRlcy5wdXNoKHN0YXRlKTtcblx0ICAgIHZhcnMgJiYgdmFycy5iYXRjaCAmJiBGbGlwLmJhdGNoKHZhcnMuYmF0Y2gpLnN0YXRlLmFkZChzdGF0ZSk7XG5cdCAgICByZXR1cm4gc3RhdGU7XG5cdCAgfTtcblxuXHQgIEZsaXAuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc3RhdGUsIHZhcnMpIHtcblx0ICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXHQgICAgXCJjbGVhclByb3BzXCIgaW4gdmFycyB8fCAodmFycy5jbGVhclByb3BzID0gdHJ1ZSk7XG5cdCAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcblx0ICAgICAgcHJvcHM6IHZhcnMucHJvcHMgfHwgc3RhdGUucHJvcHMsXG5cdCAgICAgIHNpbXBsZTogdmFycy5zaW1wbGUsXG5cdCAgICAgIGtpbGw6ICEhdmFycy5raWxsXG5cdCAgICB9KSwgdmFycywgLTEpO1xuXHQgIH07XG5cblx0ICBGbGlwLnRvID0gZnVuY3Rpb24gdG8oc3RhdGUsIHZhcnMpIHtcblx0ICAgIHJldHVybiBfZnJvbVRvKHN0YXRlLCBfcGFyc2VTdGF0ZSh2YXJzLnRhcmdldHMgfHwgc3RhdGUudGFyZ2V0cywge1xuXHQgICAgICBwcm9wczogdmFycy5wcm9wcyB8fCBzdGF0ZS5wcm9wcyxcblx0ICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcblx0ICAgICAga2lsbDogISF2YXJzLmtpbGxcblx0ICAgIH0pLCB2YXJzLCAxKTtcblx0ICB9O1xuXG5cdCAgRmxpcC5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8oZnJvbVN0YXRlLCB0b1N0YXRlLCB2YXJzKSB7XG5cdCAgICByZXR1cm4gX2Zyb21Ubyhmcm9tU3RhdGUsIHRvU3RhdGUsIHZhcnMpO1xuXHQgIH07XG5cblx0ICBGbGlwLmZpdCA9IGZ1bmN0aW9uIGZpdChmcm9tRWwsIHRvRWwsIHZhcnMpIHtcblx0ICAgIHZhciB2ID0gdmFycyA/IF9jb3B5KHZhcnMsIF9maXRSZXNlcnZlZCkgOiB7fSxcblx0ICAgICAgICBfcmVmID0gdmFycyB8fCB2LFxuXHQgICAgICAgIGFic29sdXRlID0gX3JlZi5hYnNvbHV0ZSxcblx0ICAgICAgICBzY2FsZSA9IF9yZWYuc2NhbGUsXG5cdCAgICAgICAgZ2V0VmFycyA9IF9yZWYuZ2V0VmFycyxcblx0ICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG5cdCAgICAgICAgcnVuQmFja3dhcmRzID0gX3JlZi5ydW5CYWNrd2FyZHMsXG5cdCAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZSxcblx0ICAgICAgICBzaW1wbGUgPSBfcmVmLnNpbXBsZSxcblx0ICAgICAgICBmaXRDaGlsZCA9IHZhcnMgJiYgdmFycy5maXRDaGlsZCAmJiBfZ2V0RWwodmFycy5maXRDaGlsZCksXG5cdCAgICAgICAgYmVmb3JlID0gX3BhcnNlRWxlbWVudFN0YXRlKHRvRWwsIHByb3BzLCBzaW1wbGUsIGZyb21FbCksXG5cdCAgICAgICAgYWZ0ZXIgPSBfcGFyc2VFbGVtZW50U3RhdGUoZnJvbUVsLCAwLCBzaW1wbGUsIGJlZm9yZSksXG5cdCAgICAgICAgaW5saW5lUHJvcHMgPSBwcm9wcyA/IF9tZW1vaXplZFJlbW92ZVByb3BzW3Byb3BzXSA6IF9yZW1vdmVQcm9wcztcblxuXHQgICAgcHJvcHMgJiYgX2FwcGx5UHJvcHModiwgYmVmb3JlLnByb3BzKTtcblxuXHQgICAgaWYgKHJ1bkJhY2t3YXJkcykge1xuXHQgICAgICBfcmVjb3JkSW5saW5lU3R5bGVzKGFmdGVyLCBpbmxpbmVQcm9wcyk7XG5cblx0ICAgICAgXCJpbW1lZGlhdGVSZW5kZXJcIiBpbiB2IHx8ICh2LmltbWVkaWF0ZVJlbmRlciA9IHRydWUpO1xuXG5cdCAgICAgIHYub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfYXBwbHlJbmxpbmVTdHlsZXMoYWZ0ZXIpO1xuXG5cdCAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGFic29sdXRlICYmIF9tYWtlQWJzb2x1dGUoYWZ0ZXIsIGJlZm9yZSk7XG5cdCAgICB2ID0gX2ZpdChhZnRlciwgYmVmb3JlLCBzY2FsZSB8fCBmaXRDaGlsZCwgcHJvcHMsIGZpdENoaWxkLCB2LmR1cmF0aW9uIHx8IGdldFZhcnMgPyB2IDogMCk7XG5cdCAgICByZXR1cm4gZ2V0VmFycyA/IHYgOiB2LmR1cmF0aW9uID8gZ3NhcC50byhhZnRlci5lbGVtZW50LCB2KSA6IG51bGw7XG5cdCAgfTtcblxuXHQgIEZsaXAubWFrZUFic29sdXRlID0gZnVuY3Rpb24gbWFrZUFic29sdXRlKHRhcmdldHNPclN0YXRlcywgdmFycykge1xuXHQgICAgcmV0dXJuICh0YXJnZXRzT3JTdGF0ZXMgaW5zdGFuY2VvZiBGbGlwU3RhdGUgPyB0YXJnZXRzT3JTdGF0ZXMgOiBuZXcgRmxpcFN0YXRlKHRhcmdldHNPclN0YXRlcywgdmFycykpLm1ha2VBYnNvbHV0ZSgpO1xuXHQgIH07XG5cblx0ICBGbGlwLmJhdGNoID0gZnVuY3Rpb24gYmF0Y2goaWQpIHtcblx0ICAgIGlkIHx8IChpZCA9IFwiZGVmYXVsdFwiKTtcblx0ICAgIHJldHVybiBfYmF0Y2hMb29rdXBbaWRdIHx8IChfYmF0Y2hMb29rdXBbaWRdID0gbmV3IEZsaXBCYXRjaChpZCkpO1xuXHQgIH07XG5cblx0ICBGbGlwLmtpbGxGbGlwc09mID0gZnVuY3Rpb24ga2lsbEZsaXBzT2YodGFyZ2V0cywgY29tcGxldGUpIHtcblx0ICAgICh0YXJnZXRzIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0cy50YXJnZXRzIDogX3RvQXJyYXkodGFyZ2V0cykpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgcmV0dXJuIHQgJiYgX2tpbGxGbGlwKHQuX2ZsaXAsIGNvbXBsZXRlICE9PSBmYWxzZSA/IDEgOiAyKTtcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBGbGlwLmlzRmxpcHBpbmcgPSBmdW5jdGlvbiBpc0ZsaXBwaW5nKHRhcmdldCkge1xuXHQgICAgdmFyIGYgPSBGbGlwLmdldEJ5VGFyZ2V0KHRhcmdldCk7XG5cdCAgICByZXR1cm4gISFmICYmIGYuaXNBY3RpdmUoKTtcblx0ICB9O1xuXG5cdCAgRmxpcC5nZXRCeVRhcmdldCA9IGZ1bmN0aW9uIGdldEJ5VGFyZ2V0KHRhcmdldCkge1xuXHQgICAgcmV0dXJuIChfZ2V0RWwodGFyZ2V0KSB8fCBfZW1wdHlPYmopLl9mbGlwO1xuXHQgIH07XG5cblx0ICBGbGlwLmdldEVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIGdldEVsZW1lbnRTdGF0ZSh0YXJnZXQsIHByb3BzKSB7XG5cdCAgICByZXR1cm4gbmV3IEVsZW1lbnRTdGF0ZShfZ2V0RWwodGFyZ2V0KSwgcHJvcHMpO1xuXHQgIH07XG5cblx0ICBGbGlwLmNvbnZlcnRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGNvbnZlcnRDb29yZGluYXRlcyhmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBwb2ludCkge1xuXHQgICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcblx0ICAgIHJldHVybiBwb2ludCA/IG0uYXBwbHkocG9pbnQpIDogbTtcblx0ICB9O1xuXG5cdCAgRmxpcC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcblx0ICAgIF9ib2R5JDEgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keTtcblxuXHQgICAgaWYgKF9ib2R5JDEpIHtcblx0ICAgICAgZ3NhcCA9IGNvcmU7XG5cblx0ICAgICAgX3NldERvYyhfYm9keSQxKTtcblxuXHQgICAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcblx0ICAgICAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoMC4xKTtcblxuXHQgICAgICBfY2xvc2VzdFRlbnRoID0gZnVuY3Rpb24gX2Nsb3Nlc3RUZW50aCh2YWx1ZSwgYWRkKSB7XG5cdCAgICAgICAgcmV0dXJuIHNuYXAocGFyc2VGbG9hdCh2YWx1ZSkgKyBhZGQpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gRmxpcDtcblx0fSgpO1xuXHRGbGlwLnZlcnNpb24gPSBcIjMuMTEuM1wiO1xuXHR0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5nc2FwICYmIHdpbmRvdy5nc2FwLnJlZ2lzdGVyUGx1Z2luKEZsaXApO1xuXG5cdGV4cG9ydHMuRmxpcCA9IEZsaXA7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IEZsaXA7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/dist/Flip.js\n"));

/***/ }),

/***/ "./pages/story.js":
/*!************************!*\
  !*** ./pages/story.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Index; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _src_components_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/components/layout */ \"./src/components/layout/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/index.js\");\n/* harmony import */ var gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap/dist/Flip */ \"./node_modules/gsap/dist/Flip.js\");\n/* harmony import */ var gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _src_styles_story_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/styles/story.module.scss */ \"./src/styles/story.module.scss\");\n/* harmony import */ var _src_styles_story_module_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_src_styles_story_module_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction Index() {\n    _s();\n    //console.log(logo);\n    gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.registerPlugin(gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__.Flip);\n    var flipSection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        var animateCard = function animateCard(el) {\n            var cardImage = el.querySelector(\"img\");\n            var state = gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__.Flip.getState(cards);\n            var imageState = gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__.Flip.getState(cardImage);\n            el.classList.toggle(\"active\");\n            gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__.Flip.from(state, {\n                ease: \"power1.inOut\",\n                absolute: true\n            });\n            gsap_dist_Flip__WEBPACK_IMPORTED_MODULE_5__.Flip.from(imageState, {\n                ease: \"power1.inOut\",\n                duration: 0.4,\n                delay: 0.1\n            });\n        };\n        var section = flipSection.current;\n        var cards = section.querySelectorAll(\".flip-box\");\n        //console.log(sections);\n        // Animation\n        cards.forEach(function(el) {\n            el.addEventListener(\"mouseenter\", function() {\n                return animateCard(el);\n            });\n            el.addEventListener(\"mouseleave\", function() {\n                return animateCard(el);\n            });\n        });\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_components_layout__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        header: \"show\",\n        footer: \"hide\",\n        mainDir: \"ltr\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n            className: \"vertical-wrapper h-screen flex flex-nowrap flex-row-reverse \".concat((_src_styles_story_module_scss__WEBPACK_IMPORTED_MODULE_6___default().container)),\n            id: \"vertical-scroll\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ref: flipSection,\n                    className: \"v-section h-full w-screen flex content-center overflow-hidden justify-center \".concat((_src_styles_story_module_scss__WEBPACK_IMPORTED_MODULE_6___default().color1), \" \").concat((_src_styles_story_module_scss__WEBPACK_IMPORTED_MODULE_6___default().section)),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flip-box\"\n                    }, void 0, false, {\n                        fileName: \"/Users/shiplorahman/Projects/bamistarim/pages/story.js\",\n                        lineNumber: 48,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/shiplorahman/Projects/bamistarim/pages/story.js\",\n                    lineNumber: 47,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    children: \"Story One\"\n                }, void 0, false, {\n                    fileName: \"/Users/shiplorahman/Projects/bamistarim/pages/story.js\",\n                    lineNumber: 52,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                    href: \"/\",\n                    children: \"Home Page\"\n                }, void 0, false, {\n                    fileName: \"/Users/shiplorahman/Projects/bamistarim/pages/story.js\",\n                    lineNumber: 53,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/shiplorahman/Projects/bamistarim/pages/story.js\",\n            lineNumber: 46,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/shiplorahman/Projects/bamistarim/pages/story.js\",\n        lineNumber: 45,\n        columnNumber: 5\n    }, this);\n}\n_s(Index, \"cAXO3QwJhD6OklUln3BBYczKTpk=\");\n_c = Index;\nvar _c;\n$RefreshReg$(_c, \"Index\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9zdG9yeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQXlDO0FBQ0k7QUFDbEI7QUFDVTtBQUNlO0FBQ3hCO0FBR2IsU0FBU08sS0FBSyxHQUFHOztJQUM5QixvQkFBb0I7SUFFcEJKLHFEQUFtQixDQUFDQyxnREFBSSxDQUFDLENBQUM7SUFFMUIsSUFBSUssV0FBVyxHQUFHUiw2Q0FBTSxDQUFDLElBQUksQ0FBQztJQUU5QkQsZ0RBQVMsQ0FBQyxXQUFNO1lBV0xVLFdBQVcsR0FBcEIsU0FBU0EsV0FBVyxDQUFDQyxFQUFFLEVBQUU7WUFDdkIsSUFBTUMsU0FBUyxHQUFHRCxFQUFFLENBQUNFLGFBQWEsQ0FBQyxLQUFLLENBQUM7WUFDekMsSUFBTUMsS0FBSyxHQUFHVix5REFBYSxDQUFDWSxLQUFLLENBQUM7WUFDbEMsSUFBTUMsVUFBVSxHQUFHYix5REFBYSxDQUFDUSxTQUFTLENBQUM7WUFDM0NELEVBQUUsQ0FBQ08sU0FBUyxDQUFDQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUJmLHFEQUFTLENBQUNVLEtBQUssRUFBRTtnQkFDZk8sSUFBSSxFQUFFLGNBQWM7Z0JBQ3BCQyxRQUFRLEVBQUUsSUFBSTthQUNmLENBQUMsQ0FBQztZQUNIbEIscURBQVMsQ0FBQ2EsVUFBVSxFQUFFO2dCQUNwQkksSUFBSSxFQUFFLGNBQWM7Z0JBQ3BCRSxRQUFRLEVBQUUsR0FBRztnQkFDYkMsS0FBSyxFQUFFLEdBQUc7YUFDWCxDQUFDLENBQUM7UUFDTCxDQUFDO1FBeEJELElBQU1DLE9BQU8sR0FBR2hCLFdBQVcsQ0FBQ2lCLE9BQU87UUFDbkMsSUFBSVYsS0FBSyxHQUFHUyxPQUFPLENBQUNFLGdCQUFnQixDQUFDLFdBQVcsQ0FBQztRQUNqRCx3QkFBd0I7UUFDeEIsWUFBWTtRQUVaWCxLQUFLLENBQUNZLE9BQU8sQ0FBQyxTQUFDakIsRUFBRSxFQUFLO1lBQ3BCQSxFQUFFLENBQUNrQixnQkFBZ0IsQ0FBQyxZQUFZLEVBQUU7dUJBQU1uQixXQUFXLENBQUNDLEVBQUUsQ0FBQzthQUFBLENBQUMsQ0FBQztZQUN6REEsRUFBRSxDQUFDa0IsZ0JBQWdCLENBQUMsWUFBWSxFQUFFO3VCQUFNbkIsV0FBVyxDQUFDQyxFQUFFLENBQUM7YUFBQSxDQUFDLENBQUM7UUFDM0QsQ0FBQyxDQUFDLENBQUM7SUFpQkwsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRVAscUJBQ0UsOERBQUNULDhEQUFNO1FBQUM0QixNQUFNLEVBQUMsTUFBTTtRQUFDQyxNQUFNLEVBQUMsTUFBTTtRQUFDQyxPQUFPLEVBQUMsS0FBSztrQkFDL0MsNEVBQUNQLFNBQU87WUFBQ1EsU0FBUyxFQUFFLDhEQUE2RCxDQUFtQixPQUFqQjVCLGdGQUFnQixDQUFFO1lBQUU4QixFQUFFLEVBQUMsaUJBQWlCOzs4QkFDekgsOERBQUNDLEtBQUc7b0JBQUNDLEdBQUcsRUFBRTVCLFdBQVc7b0JBQUV3QixTQUFTLEVBQUUsK0VBQThFLENBQW1CNUIsTUFBYyxDQUEvQkEsNkVBQWEsRUFBQyxHQUFDLENBQWlCLFFBQWZBLDhFQUFjLENBQUU7OEJBQ2pKLDRFQUFDK0IsS0FBRzt3QkFBQ0gsU0FBUyxFQUFDLFVBQVU7Ozs7OzRCQUVuQjs7Ozs7d0JBQ0Y7OEJBQ04sOERBQUNNLElBQUU7OEJBQUMsV0FBUzs7Ozs7d0JBQUs7OEJBQ2xCLDhEQUFDakMsa0RBQUk7b0JBQUNrQyxJQUFJLEVBQUUsR0FBRzs4QkFBRSxXQUFTOzs7Ozt3QkFBTzs7Ozs7O2dCQUN6Qjs7Ozs7WUFDSCxDQUNWO0FBQ0gsQ0FBQztHQWhEdUJqQyxLQUFLO0FBQUxBLEtBQUFBLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvc3RvcnkuanM/NDA2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9zcmMvY29tcG9uZW50cy9sYXlvdXQnXG5pbXBvcnQgeyBnc2FwIH0gZnJvbSAnZ3NhcCdcbmltcG9ydCB7IEZsaXAgfSBmcm9tICdnc2FwL2Rpc3QvRmxpcCdcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3JjL3N0eWxlcy9zdG9yeS5tb2R1bGUuc2NzcydcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluaydcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbmRleCgpIHtcbiAgLy9jb25zb2xlLmxvZyhsb2dvKTtcblxuICBnc2FwLnJlZ2lzdGVyUGx1Z2luKEZsaXApO1xuXG4gIGxldCBmbGlwU2VjdGlvbiA9IHVzZVJlZihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNlY3Rpb24gPSBmbGlwU2VjdGlvbi5jdXJyZW50O1xuICAgIGxldCBjYXJkcyA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmZsaXAtYm94Jyk7XG4gICAgLy9jb25zb2xlLmxvZyhzZWN0aW9ucyk7XG4gICAgLy8gQW5pbWF0aW9uXG5cbiAgICBjYXJkcy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4gYW5pbWF0ZUNhcmQoZWwpKTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IGFuaW1hdGVDYXJkKGVsKSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlQ2FyZChlbCkge1xuICAgICAgY29uc3QgY2FyZEltYWdlID0gZWwucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICAgIGNvbnN0IHN0YXRlID0gRmxpcC5nZXRTdGF0ZShjYXJkcyk7XG4gICAgICBjb25zdCBpbWFnZVN0YXRlID0gRmxpcC5nZXRTdGF0ZShjYXJkSW1hZ2UpO1xuICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZShcImFjdGl2ZVwiKTtcbiAgICAgIEZsaXAuZnJvbShzdGF0ZSwge1xuICAgICAgICBlYXNlOiBcInBvd2VyMS5pbk91dFwiLFxuICAgICAgICBhYnNvbHV0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBGbGlwLmZyb20oaW1hZ2VTdGF0ZSwge1xuICAgICAgICBlYXNlOiBcInBvd2VyMS5pbk91dFwiLFxuICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICBkZWxheTogMC4xXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxMYXlvdXQgaGVhZGVyPSdzaG93JyBmb290ZXI9J2hpZGUnIG1haW5EaXI9J2x0cic+XG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2B2ZXJ0aWNhbC13cmFwcGVyIGgtc2NyZWVuIGZsZXggZmxleC1ub3dyYXAgZmxleC1yb3ctcmV2ZXJzZSAke3N0eWxlcy5jb250YWluZXJ9YH0gaWQ9J3ZlcnRpY2FsLXNjcm9sbCc+XG4gICAgICAgIDxkaXYgcmVmPXtmbGlwU2VjdGlvbn0gY2xhc3NOYW1lPXtgdi1zZWN0aW9uIGgtZnVsbCB3LXNjcmVlbiBmbGV4IGNvbnRlbnQtY2VudGVyIG92ZXJmbG93LWhpZGRlbiBqdXN0aWZ5LWNlbnRlciAke3N0eWxlcy5jb2xvcjF9ICR7c3R5bGVzLnNlY3Rpb259YH0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZsaXAtYm94Jz5cblxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGgyPlN0b3J5IE9uZTwvaDI+XG4gICAgICAgIDxMaW5rIGhyZWY9eycvJ30+SG9tZSBQYWdlPC9MaW5rPlxuICAgICAgPC9zZWN0aW9uPlxuICAgIDwvTGF5b3V0PlxuICApXG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiTGF5b3V0IiwiZ3NhcCIsIkZsaXAiLCJzdHlsZXMiLCJMaW5rIiwiSW5kZXgiLCJyZWdpc3RlclBsdWdpbiIsImZsaXBTZWN0aW9uIiwiYW5pbWF0ZUNhcmQiLCJlbCIsImNhcmRJbWFnZSIsInF1ZXJ5U2VsZWN0b3IiLCJzdGF0ZSIsImdldFN0YXRlIiwiY2FyZHMiLCJpbWFnZVN0YXRlIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiZnJvbSIsImVhc2UiLCJhYnNvbHV0ZSIsImR1cmF0aW9uIiwiZGVsYXkiLCJzZWN0aW9uIiwiY3VycmVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhlYWRlciIsImZvb3RlciIsIm1haW5EaXIiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJpZCIsImRpdiIsInJlZiIsImNvbG9yMSIsImgyIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/story.js\n"));

/***/ })

});